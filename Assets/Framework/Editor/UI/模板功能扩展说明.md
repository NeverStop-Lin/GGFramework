# UI模板功能扩展说明

## 概述

UI模板系统已升级，现在支持包含代码文件的文件夹结构模板。每个模板可以包含预制体和UI类代码，创建UI时会自动复制代码并替换类名。

## 新功能特性

### 1. 文件夹结构模板

每个模板现在是一个独立的文件夹：

```
Assets/Framework/UITemplates/
  ├── DefaultUI/
  │   ├── DefaultUI.prefab    # 预制体（必需）
  │   └── DefaultUI.cs        # UI类代码（可选）
  └── 自定义模板/
      ├── 自定义模板.prefab
      └── 自定义模板.cs
```

**重要**：模板目录不在Editor文件夹内，因此代码可以作为运行时脚本挂载到预制体上。

### 2. 智能代码复制

创建UI时：
- **有模板代码**：复制代码文件，自动替换类名和命名空间
- **无模板代码**：生成默认UI类代码
- **自动挂载**：编译完成后自动将UI组件挂载到预制体

### 3. 类名自动替换

模板代码中的类名会自动替换为新UI名称：

```csharp
// 模板代码 (DefaultUI.cs)
public class DefaultUI : UIBehaviour { }

// 创建 PlayerInfoUI 后
public class PlayerInfoUI : UIBehaviour { }
```

## 实现细节

### 修改的文件

1. **UICreateDialogData.cs**
   - 新增 `TemplateCodePath` 字段，存储模板代码路径

2. **UITemplateGenerator.cs**
   - 修改为生成文件夹结构
   - 自动生成 DefaultUI 预制体和代码文件
   - 路径：`Assets/Framework/UITemplates/DefaultUI/`

3. **UICreateDialog.cs**
   - 修改模板扫描逻辑，支持文件夹模板
   - 自动检测并传递模板代码路径

4. **UIManagementTab.cs**
   - 新增 `GenerateCodeFromTemplate()` 方法，从模板复制代码
   - 新增 `GenerateUIScriptsFromTemplate()` 方法，支持模板代码或默认代码
   - 修改 `CreateNewUI()` 流程，使用新的代码生成方法

### 关键方法

#### GenerateCodeFromTemplate

```csharp
private string GenerateCodeFromTemplate(string templateCodePath, string newUIName, string namespaceName)
{
    // 1. 读取模板代码
    // 2. 使用正则提取类名
    // 3. 替换所有类名引用
    // 4. 替换命名空间
    // 5. 返回新代码
}
```

#### 类名替换逻辑

使用正则表达式：
- 提取类名：`public\s+class\s+(\w+)\s*:`
- 替换类名：`\b{旧类名}\b` → `{新类名}`
- 替换命名空间：`namespace\s+[\w\.]+` → `namespace {新命名空间}`

## 使用方法

### 创建带代码模板的UI

1. 打开 UI 管理器（`Tools > Framework > UI Manager`）
2. 点击"✚ 创建UI预制体"
3. 选择一个模板（如 DefaultUI）
4. 输入新UI名称
5. 点击创建

结果：
- 创建预制体副本
- 复制并重命名UI类代码
- 自动挂载组件到预制体

### 创建自定义模板

#### 方法1：完整模板（推荐）

1. 在 `Templates` 目录创建文件夹，如 `PopupUI`
2. 创建预制体 `PopupUI.prefab`
3. 创建代码 `PopupUI.cs`：

```csharp
using UnityEngine;
using Framework.Core;

namespace Game.UI
{
    public class PopupUI : UIBehaviour
    {
        // 可以添加自定义字段和方法
        public UnityEngine.UI.Button closeButton;
        
        protected override void OnCreate(params object[] args)
        {
            // 初始化按钮监听等
            if (closeButton != null)
            {
                closeButton.onClick.AddListener(OnCloseClick);
            }
        }
        
        private void OnCloseClick()
        {
            Close();
        }
    }
}
```

4. 在预制体上手动挂载 `PopupUI` 组件
5. 配置预制体的组件引用（如 closeButton）

现在创建新的弹窗UI时，会自动复制这个模板的代码和组件引用！

#### 方法2：仅预制体

1. 创建文件夹和预制体
2. 不创建代码文件
3. 创建UI时会自动生成默认代码

## 兼容性

### 向后兼容

- 现有的UI不受影响
- 更新、批量操作等功能正常工作
- 如果模板代码解析失败，自动回退到默认代码生成

### 迁移说明

旧的 `Template` 目录已被新的文件夹结构替代：
- 旧路径：`Assets/Framework/Editor/UI/Template/`
- 新路径：`Assets/Framework/UITemplates/`（已移出Editor目录）
- 首次打开UI管理器会自动生成默认模板

**移出Editor文件夹的原因**：
- Unity会将Editor文件夹内的所有C#脚本识别为编辑器脚本
- 编辑器脚本无法挂载到运行时GameObject上
- 模板代码必须能够挂载到预制体，因此放在 `Assets/Framework/UITemplates/`

## 测试要点

### 功能测试

1. **创建带代码模板的UI**
   - 验证代码正确复制
   - 验证类名完整替换
   - 验证命名空间正确
   - 验证组件自动挂载

2. **创建不带代码模板的UI**
   - 验证使用默认代码
   - 验证组件自动挂载

3. **自定义模板**
   - 创建多个自定义模板
   - 验证模板扫描正确
   - 验证模板选择正常

4. **错误处理**
   - 模板代码格式错误时回退到默认
   - 模板文件缺失时的提示

### 回归测试

- UI更新功能
- 批量创建/更新功能
- Canvas修复功能
- UI删除功能

## 注意事项

1. **命名规范**
   - 模板文件夹名 = 预制体名 = 代码文件名
   - 必须符合C#命名规范

2. **代码要求**
   - 必须能解析出 `public class XXX : UIBehaviour`
   - 建议继承自 `UIBehaviour`
   - 类名必须与文件名一致

3. **预制体要求**
   - 必须包含 Canvas 组件
   - 建议包含 Canvas Scaler 和 Graphic Raycaster

4. **编译时机**
   - 代码生成后会自动刷新和编译
   - 编译完成后自动挂载组件
   - 如需调试，可在编译完成回调中添加日志

## 优势

1. **提高效率**：无需手动创建代码文件
2. **减少错误**：自动类名替换，避免手动修改遗漏
3. **复用模板**：一次创建，多次使用
4. **灵活扩展**：支持自定义模板和组件
5. **向后兼容**：不影响现有功能

## 后续优化建议

1. 支持更复杂的模板，如包含子组件的UI
2. 支持模板变量替换（如占位符）
3. 提供可视化的模板管理界面
4. 支持模板分类和标签
5. 支持模板导入/导出

