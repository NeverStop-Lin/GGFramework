# 资源加载规范总结

## 🎯 核心原则

**所有业务代码应使用框架的资源系统（IResource），避免直接使用 Resources.Load**

## ✅ 已修复的模块

### 1. UI系统
- ✅ **UIFactory** - 创建UI时加载Prefab
  ```csharp
  // 修复前：Resources.Load<GameObject>(resourcePath)
  // 修复后：_resource.Load<GameObject>(resourcePath)
  ```

- ✅ **UICenter** - 预加载UI资源
  ```csharp
  // 修复前：无预加载或使用Resources.Load
  // 修复后：await _resource.LoadAsync<GameObject>(config.ResourcePath)
  ```

### 2. 音效模块
- ✅ **SoundModule** - 加载音频资源
  ```csharp
  // 修复前：Resources.Load<AudioClip>($"Sound/{name}")
  // 修复后：_resource.Load<AudioClip>($"Sound/{name}")
  ```

### 3. 配置系统
- ✅ **BaseConfig** - 加载配置文件
  ```csharp
  // 支持框架资源系统，但保留降级方案
  if (_resourceLoader != null)
      textAsset = _resourceLoader.Load<TextAsset>(Url);
  else
      textAsset = Resources.Load<TextAsset>(Url); // 框架初始化早期
  ```

## ⏭️ 保留 Resources.Load 的特殊情况

### 1. **底层实现类**（资源系统本身）

- ✅ **ResourcesLoader.cs** - Resources资源加载器实现
  ```csharp
  // 这是 Resources.Load 的封装实现，本身就是资源系统的一部分
  public T Load<T>(string path)
  {
      return Resources.Load<T>(path); // ✅ 正确
  }
  ```

- ✅ **AutoResourceLoader.cs** - 自动资源加载器
  ```csharp
  // 加载 Addressable 清单，资源系统初始化时使用
  _manifest = Resources.Load<AddressableResourceManifest>("AddressableResourceManifest"); // ✅ 正确
  ```

### 2. **框架启动配置**

- ✅ **UIProjectConfigManager.cs** - UI项目配置管理器
  ```csharp
  // 框架启动早期加载，在资源系统初始化之前
  _config = Resources.Load<UIProjectConfig>(_configPath); // ✅ 正确
  ```

- ✅ **UIManagerWindow.cs** - 编辑器工具
  ```csharp
  // 编辑器工具，不在运行时
  var config = Resources.Load<UIProjectConfig>(configPath); // ✅ 正确（编辑器）
  ```

### 3. **文档示例**（不需要修改）

- `开发扩展编码规范.md`
- `UI系统架构改造方案-MonoBehaviour.md`
- `资源系统技术实现.md`

## 📊 判断标准

| 场景 | 是否使用IResource | 原因 |
|------|------------------|------|
| 业务模块加载资源 | ✅ 必须 | 统一管理、引用计数、性能优化 |
| UI系统加载Prefab | ✅ 必须 | 缓存管理、支持Addressables |
| 音效加载AudioClip | ✅ 必须 | 资源管理、内存优化 |
| 框架启动配置 | ❌ 保留Resources | 资源系统未初始化 |
| 资源系统底层实现 | ❌ 保留Resources | 底层实现，不能依赖自己 |
| 编辑器工具 | ❌ 可保留Resources | 编辑器环境，不影响运行时 |

## 🚀 使用框架资源系统的优势

### 1. 统一管理
- 所有资源加载都通过 `IResource` 接口
- 便于追踪和监控资源使用情况
- 统一的错误处理和日志

### 2. 引用计数
- 自动管理资源引用
- 未使用的资源自动释放
- 避免内存泄漏

### 3. 多加载方式支持
- Resources
- Addressables
- AssetBundle
- 其他自定义加载器

### 4. 性能优化
- 资源缓存
- 批量预加载
- 异步加载支持

## 📝 代码规范

### ✅ 正确示例

```csharp
// 业务代码
public class MyGameLogic : MonoBehaviour
{
    [Inject] private IResource _resource;
    
    void LoadAssets()
    {
        // ✅ 使用框架资源系统
        var prefab = _resource.Load<GameObject>("Game/Prefabs/Enemy");
        var audio = await _resource.LoadAsync<AudioClip>("Game/Audio/bgm");
    }
}
```

### ❌ 错误示例

```csharp
// 业务代码
public class MyGameLogic : MonoBehaviour
{
    void LoadAssets()
    {
        // ❌ 直接使用 Resources.Load
        var prefab = Resources.Load<GameObject>("Game/Prefabs/Enemy");
    }
}
```

## 🔍 检查清单

使用以下命令检查代码中是否有不当使用：

```bash
# 搜索所有使用 Resources.Load 的地方
grep -r "Resources.Load" Assets/Game/
grep -r "Resources.Load" Assets/Framework/Modules/

# 排除底层实现和框架配置
```

## 📚 相关文档

- [资源系统技术实现](./资源系统技术实现.md)
- [UI系统概述](./UI系统概述.md)
- [开发扩展编码规范](./开发扩展编码规范.md)

