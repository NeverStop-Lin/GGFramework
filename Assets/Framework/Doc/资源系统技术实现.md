# 资源系统技术实现

> **版本**: v2.0.0  
> **面向**: 框架学习者和扩展开发者

---

## 📋 目录

1. [系统架构](#系统架构)
2. [核心类详解](#核心类详解)
3. [设计模式应用](#设计模式应用)
4. [关键技术点](#关键技术点)
5. [性能优化策略](#性能优化策略)

---

## 系统架构

### 整体架构图

```
┌─────────────────────────────────────────┐
│        GridFramework.Resource           │  统一访问入口
│             (IResource)                 │
└──────────────────┬──────────────────────┘
                   │
                   ↓
┌─────────────────────────────────────────┐
│         ResourceCenter                  │  资源管理中心
│  - 统一接口封装                          │
│  - 缓存管理                              │
│  - 加载器切换                            │
└──────────┬────────────────┬─────────────┘
           │                │
           ↓                ↓
┌──────────────────┐  ┌──────────────────┐
│  ResourceCache   │  │ IResourceLoader  │  可插拔加载器
│  - LRU 缓存     │  │                  │
│  - 引用计数      │  ├─ AutoResourceLoader    (Auto)
│  - 自动清理      │  ├─ ResourcesLoader       (Resources)
└──────────────────┘  └─ AddressableLoader     (Addressables)
                         └─ 清单查询（0ms）
```

### 设计理念

1. **接口抽象** - `IResource` 和 `IResourceLoader` 分离关注点
2. **策略模式** - 可插拔的加载器（Resources / Addressables / Auto）
3. **缓存优化** - LRU + 引用计数双重缓存策略
4. **智能检测** - 基于清单的零开销资源定位

---

## 核心类详解

### 1. IResource 接口

**文件**：`Assets/Framework/Core/Interface/IResource.cs`

**设计目的**：
- 定义统一的资源管理接口
- 隔离实现细节
- 便于依赖注入

**核心方法**：

```csharp
public interface IResource
{
    // 加载
    T Load<T>(string path) where T : UnityEngine.Object;
    Task<T> LoadAsync<T>(string path) where T : UnityEngine.Object;
    Task<T> LoadAsync<T>(string path, Action<float> onProgress) where T : UnityEngine.Object;
    
    // 预加载
    Task PreloadAsync(params string[] paths);
    Task PreloadAsync(Action<float> onProgress, params string[] paths);
    
    // 释放
    void Release(string path);
    void Release(UnityEngine.Object asset);
    void ReleaseUnused();
    void ClearCache();
    
    // 查询
    bool IsLoaded(string path);
    int GetReferenceCount(string path);
    int CacheCount { get; }
}
```

**设计要点**：
- 泛型方法支持各种资源类型
- 同步和异步两种加载方式
- 支持进度回调（UX 优化）
- 提供查询接口便于调试

---

### 2. ResourceCache 资源缓存

**文件**：`Assets/Framework/Core/Systems/Resource/ResourceCache.cs`

**设计目的**：
- 避免重复加载相同资源
- 管理资源生命周期
- 控制内存使用

**核心数据结构**：

```csharp
internal class ResourceCacheItem
{
    public string Path;                  // 资源路径
    public UnityEngine.Object Asset;     // 资源对象
    public int ReferenceCount;           // 引用计数 ⭐
    public DateTime LastAccessTime;      // 最后访问时间（LRU）⭐
    public long Size;                    // 资源大小估算
}

public class ResourceCache
{
    // 双索引设计 ⭐
    private Dictionary<string, ResourceCacheItem> _cacheByPath;    // 路径索引
    private Dictionary<UnityEngine.Object, ResourceCacheItem> _cacheByAsset;  // 对象索引
    
    private long _maxCacheSize;   // 最大缓存大小
    private long _currentCacheSize;  // 当前缓存大小
}
```

**关键实现**：

#### 1. 双索引设计

```csharp
// 为什么需要两个索引？
_cacheByPath[path] = item;    // 通过路径快速查找
_cacheByAsset[asset] = item;  // 通过对象快速查找

// 使用场景
// 场景1：通过路径加载
var asset = _cacheByPath["UI/MainMenu"];

// 场景2：通过对象释放
GridFramework.Resource.Release(gameObject);  // 需要通过对象找到路径
```

#### 2. 引用计数

```csharp
public void Add(string path, UnityEngine.Object asset)
{
    if (_cacheByPath.TryGetValue(path, out var item))
    {
        item.ReferenceCount++;  // 已存在，增加引用
        return;
    }
    
    // 新建缓存项，引用计数为 1
    var cacheItem = new ResourceCacheItem(path, asset);
    _cacheByPath[path] = cacheItem;
}

public void RemoveReference(string path)
{
    if (_cacheByPath.TryGetValue(path, out var item))
    {
        item.ReferenceCount = Mathf.Max(0, item.ReferenceCount - 1);
        // 引用计数为 0 时才可以被 LRU 清理
    }
}
```

#### 3. LRU 缓存策略

```csharp
private void CheckCacheSize()
{
    if (_currentCacheSize <= _maxCacheSize)
        return;
    
    // 按最后访问时间排序
    var sortedItems = new List<ResourceCacheItem>(_cacheByPath.Values);
    sortedItems.Sort((a, b) => a.LastAccessTime.CompareTo(b.LastAccessTime));
    
    // 移除引用计数为 0 的最旧资源
    foreach (var item in sortedItems)
    {
        if (item.ReferenceCount <= 0)
        {
            RemoveFromCache(item);
            
            if (_currentCacheSize <= _maxCacheSize * 0.8f)  // 清理到 80%
                break;
        }
    }
}
```

**设计亮点**：
- **双重保护**：引用计数 + LRU，不会误删正在使用的资源
- **渐进式清理**：清理到 80% 而非 100%，避免频繁触发
- **大小估算**：根据资源类型估算大小，控制总内存

---

### 3. IResourceLoader 加载器接口

**文件**：`Assets/Framework/Core/Interface/IResourceLoader.cs`

**设计目的**：
- 抽象加载逻辑
- 支持多种加载方式
- 便于扩展新的加载器

**接口定义**：

```csharp
public interface IResourceLoader
{
    T Load<T>(string path) where T : UnityEngine.Object;
    Task<T> LoadAsync<T>(string path, Action<float> onProgress = null) where T : UnityEngine.Object;
    void Release(UnityEngine.Object asset);
    bool Exists(string path);
    
    string LoaderName { get; }
    bool IsAvailable { get; }  // ⭐ 运行时可用性检查
}
```

**为什么需要 IsAvailable？**

```csharp
// AddressableLoader 可能不可用（未安装包）
public bool IsAvailable => _isAddressablesAvailable;

// ResourcesLoader 始终可用
public bool IsAvailable => true;

// 使用场景
if (loader.IsAvailable)
{
    // 使用此加载器
}
else
{
    // 降级到其他加载器
}
```

---

### 4. ResourcesLoader 实现

**文件**：`Assets/Framework/Core/Systems/Resource/ResourcesLoader.cs`

**实现要点**：

```csharp
public T Load<T>(string path) where T : UnityEngine.Object
{
    try
    {
        var asset = Resources.Load<T>(path);
        if (asset == null)
        {
            Debug.LogWarning($"资源加载失败: {path}");
        }
        return asset;
    }
    catch (Exception e)
    {
        Debug.LogError($"资源加载异常: {path}\n{e}");
        return null;
    }
}
```

**为什么要 try-catch？**
- Resources.Load 可能抛出异常（路径非法、类型错误）
- 统一错误处理，避免崩溃
- 提供友好的错误信息

**异步加载实现**：

```csharp
public async Task<T> LoadAsync<T>(string path, Action<float> onProgress = null) 
    where T : UnityEngine.Object
{
    var request = Resources.LoadAsync<T>(path);
    
    // 轮询检查进度
    while (!request.isDone)
    {
        onProgress?.Invoke(request.progress);  // 回调进度
        await Task.Yield();  // 让出控制权，不阻塞主线程
    }
    
    onProgress?.Invoke(1f);  // 完成时回调 100%
    return request.asset as T;
}
```

**为什么用 Task.Yield()？**
- `await Task.Yield()` 让出当前帧
- 避免阻塞主线程
- 保持游戏流畅运行

---

### 5. AddressableLoader 反射实现

**文件**：`Assets/Framework/Core/Systems/Resource/AddressableLoader.cs`

**核心挑战**：
- Addressables 是可选包，可能未安装
- 不能直接 `using UnityEngine.AddressableAssets`（会编译错误）
- 需要运行时检测是否可用

**解决方案：反射**

```csharp
private bool _isAddressablesAvailable;
private Type _addressablesType;
private MethodInfo _loadAssetAsyncMethod;
private MethodInfo _releaseMethod;

private void CheckAddressablesAvailability()
{
    // 通过完全限定名查找类型
    _addressablesType = Type.GetType(
        "UnityEngine.AddressableAssets.Addressables, Unity.Addressables"
    );
    
    if (_addressablesType != null)
    {
        // 获取方法
        _loadAssetAsyncMethod = _addressablesType.GetMethod(
            "LoadAssetAsync",
            BindingFlags.Public | BindingFlags.Static,
            null,
            new Type[] { typeof(object) },
            null
        );
        
        _releaseMethod = _addressablesType.GetMethod("Release", ...);
        
        _isAddressablesAvailable = true;
    }
}
```

**为什么用反射？**
1. **条件依赖** - Addressables 包可能不存在
2. **动态检测** - 运行时判断是否可用
3. **避免编译错误** - 不需要 `#if` 预处理指令
4. **用户友好** - 自动降级，不报错

**反射调用示例**：

```csharp
public async Task<T> LoadAsync<T>(string path, Action<float> onProgress = null) 
    where T : UnityEngine.Object
{
    if (!_isAddressablesAvailable)
    {
        Debug.LogError("Addressables 不可用");
        return null;
    }
    
    // 使用反射调用 Addressables.LoadAssetAsync<T>(path)
    var genericMethod = _loadAssetAsyncMethod.MakeGenericMethod(typeof(T));
    var handle = genericMethod.Invoke(null, new object[] { path });
    
    // 获取属性（也是反射）
    var isDoneProperty = handle.GetType().GetProperty("IsDone");
    var percentProperty = handle.GetType().GetProperty("PercentComplete");
    var resultProperty = handle.GetType().GetProperty("Result");
    
    // 等待加载完成
    while (!(bool)isDoneProperty.GetValue(handle))
    {
        float progress = (float)percentProperty.GetValue(handle);
        onProgress?.Invoke(progress);
        await Task.Yield();
    }
    
    return resultProperty.GetValue(handle) as T;
}
```

**反射的性能影响**：
- 首次获取方法/属性：~0.1ms（初始化时一次性）
- 后续调用：~0.01ms（可忽略）
- 相比加载资源本身的时间（几十到几百ms），反射开销可以忽略

---

### 6. AutoResourceLoader 自动加载器

**文件**：`Assets/Framework/Core/Systems/Resource/AutoResourceLoader.cs`

**设计核心**：清单查询 + 试错降级

#### 核心思路

```
加载资源
  ↓
├─ 有清单？
│   ├─ 是 → 查询清单（0ms）⭐⭐⭐
│   │   ├─ 在清单中 → Addressables
│   │   └─ 不在清单中 → Resources
│   │
│   └─ 否 → 试错模式
│       ├─ 先 Resources（0.1ms）⭐⭐
│       └─ 后 Addressables（5-10ms）⭐
```

#### 清单查询实现

```csharp
public async Task<T> LoadAsync<T>(string path, Action<float> onProgress = null) 
    where T : UnityEngine.Object
{
    // 策略1：清单查询（最快，0ms）⭐⭐⭐
    if (_manifestLoaded && _manifest.Contains(path))
    {
        Debug.Log($"清单命中，使用 Addressables: {path}");
        return await _addressableLoader.LoadAsync<T>(path, onProgress);
    }
    
    // 策略2：缓存查询（次快，0ms）⭐⭐
    if (_addressableCheckCache.TryGetValue(path, out bool isAddressable))
    {
        if (isAddressable)
            return await _addressableLoader.LoadAsync<T>(path, onProgress);
        else
            return await _resourcesLoader.LoadAsync<T>(path, onProgress);
    }
    
    // 策略3：试错模式（降级，0.1-5ms）⭐
    // 先快后慢
    var asset = await _resourcesLoader.LoadAsync<T>(path, onProgress);
    if (asset != null)
    {
        _addressableCheckCache[path] = false;  // 缓存结果
        return asset;
    }
    
    if (_addressablesAvailable)
    {
        asset = await _addressableLoader.LoadAsync<T>(path, onProgress);
        if (asset != null)
        {
            _addressableCheckCache[path] = true;  // 缓存结果
            return asset;
        }
    }
    
    return null;
}
```

**三层优化机制**：

| 层级 | 方式 | 耗时 | 命中率 | 优先级 |
|------|------|------|--------|--------|
| 第1层 | 清单查询 | 0ms | 100%（有清单） | ⭐⭐⭐ |
| 第2层 | 缓存查询 | 0ms | 90%+（二次加载） | ⭐⭐ |
| 第3层 | 试错模式 | 0.1-5ms | 100%（降级） | ⭐ |

**为什么先 Resources 后 Addressables？**

```
性能分析：
- Resources.Load 检测：~0.1ms（内存哈希表查找）
- Addressables 检测：~5-10ms（资源定位系统查询）

假设 80% 资源在 Resources，20% 在 Addressables：

方案1（框架采用）：先 Resources
- 80 × 0.1ms + 20 × 5.1ms = 110ms

方案2：先 Addressables
- 100 × 5.1ms = 510ms

节省：400ms（快 4.6 倍）
```

---

### 7. AddressableResourceManifest 清单

**文件**：`Assets/Framework/Core/Systems/Resource/AddressableResourceManifest.cs`

**设计目的**：
- 提前生成资源索引
- 运行时零开销查询
- 避免试错检测

**数据结构**：

```csharp
[CreateAssetMenu]
public class AddressableResourceManifest : ScriptableObject
{
    public List<ResourceEntry> resources;  // 序列化存储
    
    // 运行时优化（不序列化）⭐
    [NonSerialized] private HashSet<string> _addressHashSet;  // 快速查询
    [NonSerialized] private Dictionary<string, ResourceEntry> _addressDictionary;  // 详细信息
    [NonSerialized] private bool _initialized;
    
    public void Initialize()
    {
        // 构建哈希表
        _addressHashSet = new HashSet<string>();
        _addressDictionary = new Dictionary<string, ResourceEntry>();
        
        foreach (var entry in resources)
        {
            _addressHashSet.Add(entry.address);
            _addressDictionary[entry.address] = entry;
        }
        
        _initialized = true;
    }
    
    public bool Contains(string address)
    {
        if (!_initialized) Initialize();
        return _addressHashSet.Contains(address);  // O(1) 查询
    }
}
```

**为什么用 HashSet？**

```
性能对比：
- List.Contains(): O(n) - 线性查找，100个资源需要100次比较
- HashSet.Contains(): O(1) - 哈希查找，1次即可

100个资源查询：
- List: ~0.01ms × 100 = 1ms
- HashSet: ~0.00001ms × 100 = 0.001ms

HashSet 快 1000 倍！
```

**为什么不序列化 HashSet？**

```csharp
// List 序列化到 ScriptableObject（持久化）
public List<ResourceEntry> resources;

// HashSet 不序列化（运行时构建）⭐
[NonSerialized] private HashSet<string> _addressHashSet;

原因：
1. ScriptableObject 不支持直接序列化 HashSet
2. 从 List 构建 HashSet 很快（~0.1ms，100个资源）
3. 初始化时构建一次即可
```

---

### 8. AddressableManifestGenerator 清单生成器

**文件**：`Assets/Framework/Editor/Resource/AddressableManifestGenerator.cs`

**设计目的**：
- 编辑器工具，自动扫描 Addressable 资源
- 生成资源清单文件
- 支持 GUI 和命令行两种方式

**核心实现**：

```csharp
void GenerateManifest()
{
    // 1. 检查 Addressables 是否安装（反射）
    var addressablesSettingsType = Type.GetType(
        "UnityEditor.AddressableAssets.Settings.AddressableAssetSettings, Unity.Addressables.Editor"
    );
    
    if (addressablesSettingsType == null)
    {
        EditorUtility.DisplayDialog("未安装", "请安装 Addressables 包", "确定");
        return;
    }
    
    // 2. 获取 Addressables Settings（反射）
    var getSettingsMethod = addressablesSettingsType.GetMethod("get_DefaultObject", ...);
    var settings = getSettingsMethod?.Invoke(null, null);
    
    // 3. 创建或加载清单
    var manifest = AssetDatabase.LoadAssetAtPath<AddressableResourceManifest>(MANIFEST_PATH);
    if (manifest == null)
    {
        manifest = CreateInstance<AddressableResourceManifest>();
        AssetDatabase.CreateAsset(manifest, MANIFEST_PATH);
    }
    
    manifest.Clear();
    
    // 4. 遍历所有分组（反射）
    var groupsProperty = addressablesSettingsType.GetProperty("groups");
    var groups = groupsProperty.GetValue(settings) as IList;
    
    foreach (var group in groups)
    {
        // 获取分组中的条目
        var entriesProperty = group.GetType().GetProperty("entries");
        var entries = entriesProperty?.GetValue(group) as IList;
        
        foreach (var entry in entries)
        {
            // 获取 Address 和 GUID
            var address = entry.GetType().GetProperty("address")?.GetValue(entry) as string;
            var guid = entry.GetType().GetProperty("guid")?.GetValue(entry) as string;
            
            // 添加到清单
            manifest.AddResource(address, assetType, guid, assetPath, groupName);
        }
    }
    
    // 5. 保存清单
    EditorUtility.SetDirty(manifest);
    AssetDatabase.SaveAssets();
}
```

**为什么用反射访问 Addressables Editor API？**

1. **避免编译依赖** - Editor 代码在 `#if UNITY_EDITOR` 中
2. **包可选** - Addressables 可能未安装
3. **兼容性** - 不同版本 API 可能变化

---

### 9. ResourceCenter 管理中心

**文件**：`Assets/Framework/Core/Systems/Resource/ResourceCenter.cs`

**设计目的**：
- 统一资源管理入口
- 管理多个加载器
- 集成缓存系统

**核心实现**：

```csharp
public class ResourceCenter : IResource
{
    private readonly ResourceCache _cache;  // 缓存管理器
    private IResourceLoader _loader;  // 当前加载器
    private readonly Dictionary<ResourceLoaderType, IResourceLoader> _loaders;  // 加载器字典
    
    public ResourceCenter()
    {
        _cache = new ResourceCache(100f);  // 100MB 缓存
        _loaders = new Dictionary<ResourceLoaderType, IResourceLoader>();
        
        // 注册三个加载器
        RegisterLoader(ResourceLoaderType.Auto, new AutoResourceLoader());
        RegisterLoader(ResourceLoaderType.Resources, new ResourcesLoader());
        RegisterLoader(ResourceLoaderType.Addressables, new AddressableLoader());
        
        // 默认使用自动加载器
        CurrentLoaderType = ResourceLoaderType.Auto;
    }
}
```

**加载流程**：

```csharp
public async Task<T> LoadAsync<T>(string path) where T : UnityEngine.Object
{
    // 1. 先从缓存获取 ⭐
    var cachedAsset = _cache.Get<T>(path);
    if (cachedAsset != null)
    {
        _cache.AddReference(path);  // 增加引用计数
        return cachedAsset;
    }
    
    // 2. 使用加载器加载
    var asset = await _loader.LoadAsync<T>(path);
    
    // 3. 加入缓存
    if (asset != null)
    {
        _cache.Add(path, asset);
    }
    
    return asset;
}
```

**分层设计**：

```
ResourceCenter（管理层）
  ├─ 提供统一接口
  ├─ 管理缓存
  └─ 切换加载器
     ↓
ResourceCache（缓存层）
  ├─ LRU 策略
  └─ 引用计数
     ↓
IResourceLoader（加载层）
  ├─ AutoResourceLoader
  ├─ ResourcesLoader
  └─ AddressableLoader
```

---

## 设计模式应用

### 1. 策略模式（Strategy Pattern）

```csharp
// IResourceLoader 是策略接口
public interface IResourceLoader { ... }

// 不同的加载策略
public class ResourcesLoader : IResourceLoader { ... }
public class AddressableLoader : IResourceLoader { ... }
public class AutoResourceLoader : IResourceLoader { ... }

// ResourceCenter 是上下文
public class ResourceCenter
{
    private IResourceLoader _loader;  // 当前策略
    
    public ResourceLoaderType CurrentLoaderType
    {
        set
        {
            _loader = _loaders[value];  // 切换策略
        }
    }
}
```

**好处**：
- 加载方式可以运行时切换
- 新增加载器无需修改现有代码
- 符合开闭原则（对扩展开放，对修改封闭）

### 2. 单例模式（Singleton Pattern）

```csharp
public class GridFramework : MonoBehaviour
{
    public static GridFramework Instance;
    
    void Awake()
    {
        Instance = this;
    }
    
    public static IResource Resource => Instance?._resource;
}
```

**为什么用单例？**
- 全局唯一的资源管理器
- 方便访问（GridFramework.Resource）
- 避免重复初始化

### 3. 依赖注入模式（DI Pattern）

```csharp
public class ResourceCenter : IResource
{
    [Inject]
    public ResourceCenter()
    {
        // Zenject 自动注入
    }
}

// FrameworkInstaller 中注册
Container.Bind<IResource>().To<ResourceCenter>().AsSingle();
```

**好处**：
- 解耦合
- 便于测试
- 生命周期自动管理

### 4. 对象池模式（Object Pool Pattern）

```csharp
public class GameObjectPool
{
    private readonly Stack<GameObject> _pool;  // 池
    
    public GameObject Spawn()
    {
        if (_pool.Count > 0)
            return _pool.Pop();  // 从池中获取
        else
            return Object.Instantiate(_prefab);  // 创建新对象
    }
    
    public void Despawn(GameObject obj)
    {
        obj.SetActive(false);
        _pool.Push(obj);  // 归还到池
    }
}
```

**核心原理**：
- 对象复用，避免频繁创建销毁
- 减少 GC 压力
- 内存稳定

### 5. 工厂模式（Factory Pattern）

```csharp
// ObjectPool 是通用工厂
public class ObjectPool<T> where T : class, new()
{
    private readonly Func<T> _createFunc;  // 对象创建工厂方法
    
    public ObjectPool(Func<T> createFunc = null)
    {
        _createFunc = createFunc ?? (() => new T());
    }
    
    public T Spawn()
    {
        return _pool.Count > 0 ? _pool.Pop() : _createFunc();
    }
}

// 使用
var pool = new ObjectPool<GameEvent>(
    createFunc: () => new GameEvent()  // 自定义创建逻辑
);
```

---

## 关键技术点

### 1. 反射（Reflection）

**使用场景**：
- 检测 Addressables 是否安装
- 动态调用 Addressables API
- 访问 Addressables Editor API

**实现要点**：

```csharp
// 查找类型
Type type = Type.GetType("完全限定名, 程序集名");

// 查找方法
MethodInfo method = type.GetMethod(
    "方法名",
    BindingFlags.Public | BindingFlags.Static,
    null,
    new Type[] { 参数类型 },
    null
);

// 调用方法
object result = method.Invoke(null, new object[] { 参数值 });

// 泛型方法
MethodInfo genericMethod = method.MakeGenericMethod(typeof(T));
object result = genericMethod.Invoke(null, parameters);
```

**性能考虑**：
- 反射比直接调用慢 10-100 倍
- 但相比资源加载（几十到几百 ms），可以忽略
- 缓存 MethodInfo 避免重复查找

### 2. 异步编程（async/await）

**async/await 的本质**：

```csharp
// async 方法返回 Task
public async Task<GameObject> LoadAsync(string path)
{
    var request = Resources.LoadAsync<GameObject>(path);
    
    // await 等待异步操作完成
    while (!request.isDone)
    {
        await Task.Yield();  // 让出控制权
    }
    
    return request.asset as GameObject;
}

// 编译器生成状态机
// 每次 await 会暂停执行，保存状态
// 完成后恢复执行
```

**Task.Yield() 的作用**：

```csharp
await Task.Yield();

// 等价于
// 1. 暂停当前执行
// 2. 返回 Unity 主线程
// 3. 下一帧继续执行

// 好处：不阻塞主线程，游戏保持流畅
```

### 3. 泛型（Generics）

**为什么大量使用泛型？**

```csharp
// 不用泛型（需要类型转换）
UnityEngine.Object LoadAsset(string path);

var prefab = LoadAsset("UI/MainMenu") as GameObject;  // 需要转换
var audio = LoadAsset("Audio/BGM") as AudioClip;

// 使用泛型（类型安全）⭐
T Load<T>(string path) where T : UnityEngine.Object;

var prefab = Load<GameObject>("UI/MainMenu");  // 类型安全
var audio = Load<AudioClip>("Audio/BGM");

// 好处：
// 1. 编译时类型检查
// 2. 无需类型转换
// 3. 代码更清晰
```

### 4. 约束（Constraints）

```csharp
// 泛型约束
public T Load<T>(string path) where T : UnityEngine.Object
                                      ↑
                                   约束：T 必须继承 UnityEngine.Object

// 为什么需要约束？
// 1. 限制类型范围（只能加载 Unity 资源）
// 2. 编译时检查
// 3. 避免类型错误

// ✅ 正确
Load<GameObject>("path");
Load<AudioClip>("path");

// ❌ 错误（编译失败）
Load<int>("path");  // int 不是 UnityEngine.Object
Load<string>("path");  // string 不是 UnityEngine.Object
```

### 5. 委托和事件（Delegates & Events）

**进度回调**：

```csharp
// 使用 Action<float> 作为进度回调
public async Task<T> LoadAsync<T>(string path, Action<float> onProgress = null)
{
    while (!request.isDone)
    {
        onProgress?.Invoke(request.progress);  // 回调进度 0-1
        await Task.Yield();
    }
}

// 使用
await LoadAsync<GameObject>("path", progress => 
{
    loadingBar.value = progress;  // 更新进度条
    loadingText.text = $"{progress * 100:F0}%";
});
```

**为什么用 Action？**
- 简洁：不需要定义 delegate
- 灵活：可以是匿名方法、Lambda 表达式
- 标准：.NET 标准库

---

## 性能优化策略

### 1. 缓存优化

```csharp
// 三级缓存
第1级：资源对象缓存（ResourceCache）
  ├─ 避免重复加载
  └─ LRU + 引用计数

第2级：清单查询缓存（HashSet）
  ├─ Addressable 资源索引
  └─ O(1) 查询

第3级：试错结果缓存（Dictionary）
  ├─ 记录试错结果
  └─ 避免重复检测
```

### 2. 查询优化

```csharp
// 查询性能对比
方式1：清单查询
_manifest.Contains(path)  // HashSet
→ O(1) 复杂度，~0.00001ms

方式2：试错 Resources
Resources.Load(path)
→ O(1) 哈希查找，~0.1ms

方式3：试错 Addressables
Addressables.LoadResourceLocationsAsync(path)
→ 资源定位查询，~5-10ms

优先级：清单 > Resources > Addressables
```

### 3. 内存优化

```csharp
// LRU 清理策略
private void CheckCacheSize()
{
    if (_currentCacheSize > _maxCacheSize)
    {
        // 只清理引用计数为 0 的资源
        // 正在使用的资源不会被清理 ⭐
        foreach (var item in sortedByTime)
        {
            if (item.ReferenceCount <= 0)
            {
                RemoveFromCache(item);
            }
        }
    }
}
```

### 4. 对象池优化

```csharp
// 减少 GC 压力
不使用对象池：
- 每次 Instantiate：分配内存 + GC
- 每次 Destroy：标记待回收 + GC

使用对象池：
- Spawn：从池中取（无 GC）
- Despawn：放回池中（无 GC）

性能提升：
- 减少 GC 次数 90%+
- 减少 CPU 峰值
- 内存使用稳定
```

---

## 技术难点与解决方案

### 难点1：Addressables 可选依赖

**问题**：
- Addressables 是可选包，可能未安装
- 直接引用会导致编译错误

**解决方案**：
```csharp
// 使用反射动态检测和调用
Type addressablesType = Type.GetType("..., Unity.Addressables");

if (addressablesType != null)
{
    // Addressables 可用
}
else
{
    // Addressables 不可用，降级
}
```

### 难点2：多个 Resources 目录路径冲突

**问题**：
- Unity 合并所有 Resources 目录
- 可能出现路径冲突

**解决方案**：
```
命名规范：
- Game/Resources/game_config.json → "game_config"
- Framework/Resources/framework_config.json → "framework_config"
- 使用前缀避免冲突
```

### 难点3：异步加载的线程安全

**问题**：
- 多个异步加载可能同时访问缓存
- 需要线程安全

**解决方案**：
```csharp
// Unity 主线程模型
// 所有 async/await 都在主线程执行
// 不需要加锁！⭐

// Task.Yield() 确保在主线程
await Task.Yield();  // 下一帧在主线程继续
```

### 难点4：资源释放时机

**问题**：
- 何时释放资源？
- 引用计数如何管理？

**解决方案**：
```csharp
// 引用计数 + 手动释放
Load -> ReferenceCount++
Release -> ReferenceCount--

// ReferenceCount == 0 时可以被 LRU 清理
// 但不会立即清理，等缓存满时再清理

// 优点：
// 1. 不会误删正在使用的资源
// 2. 短时间重复加载可以命中缓存
// 3. 内存可控
```

---

## 扩展开发指南

### 如何添加新的加载器

```csharp
// 1. 实现 IResourceLoader 接口
public class CustomLoader : IResourceLoader
{
    public string LoaderName => "CustomLoader";
    public bool IsAvailable => true;
    
    public T Load<T>(string path) where T : UnityEngine.Object
    {
        // 实现加载逻辑
    }
    
    // ... 实现其他接口方法
}

// 2. 在 ResourceLoaderType 枚举中添加类型
public enum ResourceLoaderType
{
    Auto,
    Resources,
    Addressables,
    Custom  // 新增
}

// 3. 在 ResourceCenter 构造函数中注册
RegisterLoader(ResourceLoaderType.Custom, new CustomLoader());

// 4. 使用
var center = GridFramework.Resource as ResourceCenter;
center.CurrentLoaderType = ResourceLoaderType.Custom;
```

### 如何自定义缓存策略

```csharp
// 继承 ResourceCache 或创建新的缓存类
public class CustomResourceCache : ResourceCache
{
    // 重写清理策略
    protected override void CheckCacheSize()
    {
        // 自定义清理逻辑
        // 例如：FIFO、随机清理等
    }
}

// 在 ResourceCenter 中使用
_cache = new CustomResourceCache(200f);
```

---

## 学习要点总结

### 架构层面

1. **分层设计** - Interface / Center / Loader / Cache 四层架构
2. **职责分离** - 每个类只负责一件事
3. **可扩展性** - 接口抽象 + 策略模式

### 技术层面

1. **反射技术** - 处理可选依赖
2. **异步编程** - async/await 不阻塞主线程
3. **泛型约束** - 类型安全
4. **缓存策略** - LRU + 引用计数
5. **哈希优化** - HashSet 快速查询

### 性能层面

1. **多级缓存** - 资源缓存 + 清单缓存 + 试错缓存
2. **智能降级** - 清单 → 试错 → 失败
3. **先快后慢** - Resources 优先于 Addressables
4. **对象池** - 减少 GC，提升性能

---

## 推荐阅读

### Unity 官方文档
- Resources API
- Addressables 系统
- ScriptableObject
- AssetBundle

### C# 技术
- 反射（Reflection）
- 异步编程（async/await）
- 泛型（Generics）
- 委托和事件

### 设计模式
- 策略模式
- 单例模式
- 工厂模式
- 对象池模式

---

**通过学习这些实现，你可以设计出更好的框架！** 📚✨

