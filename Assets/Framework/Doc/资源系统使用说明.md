# 资源系统使用说明

> **版本**: v2.0.0  
> **GGFramework 资源管理系统**

---

## ⚙️ Resources 配置与使用

### 目录位置

```
任何名为 "Resources" 的文件夹都会被 Unity 识别：
- Assets/Game/Resources/
- Assets/Generations/Resources/
- Assets/Framework/Resources/
```

### 使用注意事项

#### 1. 路径规则

```csharp
// ✅ 正确：相对于 Resources 目录，不含扩展名
物理位置：Assets/Game/Resources/UI/Icons/gold.png
加载路径：GridFramework.Resource.Load<Sprite>("UI/Icons/gold")

// ❌ 错误：不要包含 Resources 路径
GridFramework.Resource.Load<Sprite>("Resources/UI/Icons/gold")  // 错误
GridFramework.Resource.Load<Sprite>("Game/Resources/UI/Icons/gold")  // 错误

// ❌ 错误：不要包含扩展名
GridFramework.Resource.Load<Sprite>("UI/Icons/gold.png")  // 错误
```

#### 2. 避免路径冲突

```
多个 Resources 目录会被合并，避免相同路径：

❌ 冲突示例：
- Assets/Game/Resources/Config.json
- Assets/Framework/Resources/Config.json
→ 加载 "Config" 时不确定加载哪个

✅ 正确做法：
- Assets/Game/Resources/game_config.json
- Assets/Framework/Resources/framework_config.json
→ 路径不同，无冲突
```

#### 3. 资源会全部打包

```
特点：
- Resources 下所有资源都会打包到应用中
- 即使未使用的资源也会打包
- 无法完全卸载（UnloadAsset 只卸载资源本身）

建议：
- 只放需要动态加载的资源
- 控制 Resources 目录大小
- 定期清理未使用资源
```

#### 4. 支持的资源类型

```csharp
// 常用资源类型
GameObject         // 预制体
Sprite            // 精灵图
Texture2D         // 纹理
AudioClip         // 音频
TextAsset         // 文本（json、txt、bytes）
Material          // 材质
AnimationClip     // 动画
ScriptableObject  // 脚本化对象
```

---

## 🎯 Addressables 配置与使用

### 安装 Addressables

```
方法1：Package Manager
1. Window → Package Manager
2. 搜索 "Addressables"
3. 点击 Install

方法2：manifest.json
编辑 Packages/manifest.json，添加：
{
  "dependencies": {
    "com.unity.addressables": "1.21.19"
  }
}
```

### 初始化 Addressables

```
首次使用：
1. Window → Asset Management → Addressables → Groups
2. 点击 "Create Addressables Settings"
3. 创建默认配置
```

### 标记资源为 Addressable

#### 方法1：Inspector 标记（推荐）

```
1. 选中资源（预制体、音频、场景等）
2. 勾选 Inspector 顶部的 "Addressable" 复选框
3. 设置 Address（资源的加载路径）

示例：
资源：Assets/AddressableAssets/Game/UI/Prefabs/main_menu.prefab
Address：Game/UI/Prefabs/main_menu
```

#### 方法2：批量标记

```
1. Window → Asset Management → Addressables → Groups
2. 将资源拖拽到分组中
3. 右键设置 Address
```

### 使用注意事项

#### 1. Address 路径规范

```csharp
// ✅ 正确：清晰的层级结构
Address: "Game/UI/Prefabs/main_menu"
Address: "Game/Audio/Music/bgm_battle"
Address: "Game/3D/Prefabs/Characters/player"

// ❌ 不好：路径不清晰
Address: "main_menu"
Address: "bgm1"
Address: "player_prefab"

// 建议：Address 与物理路径结构保持一致（去掉 Assets/AddressableAssets/ 前缀）
```

#### 2. 必须构建 Addressables

```
标记资源后，必须构建才能在运行时使用：

构建步骤：
1. Window → Asset Management → Addressables → Groups
2. Build → New Build → Default Build Script
3. 等待构建完成

注意：
- 每次修改 Addressable 资源后需要重新构建
- 开发时可以使用 "Use Asset Database" 模式（Play Mode Script）
```

#### 3. Address 不要重复

```
❌ 错误：多个资源使用相同 Address
资源1：ui_main_menu.prefab → Address: "MainMenu"
资源2：main_menu_bg.png → Address: "MainMenu"
→ 冲突！

✅ 正确：每个资源唯一的 Address
资源1：ui_main_menu.prefab → Address: "Game/UI/Prefabs/main_menu"
资源2：main_menu_bg.png → Address: "Game/UI/Textures/main_menu_bg"
```

#### 4. 资源分组策略

```
推荐按功能分组：
- UI Group        → 所有 UI 资源
- Audio Group     → 所有音频资源
- Scenes Group    → 所有场景
- Characters Group → 所有角色

好处：
- 便于管理
- 可以按组加载/卸载
- 支持远程更新
```

#### 5. 资源依赖自动处理

```
Addressables 自动处理依赖关系：
- 预制体引用的材质、纹理
- UI 引用的图集、字体
- 场景引用的预制体

无需手动管理依赖！
```

---

## 🔄 框架自动切换

### 工作原理

```csharp
// 框架默认使用 Auto 模式（自动检测）
// 加载资源时：
// 1. 查询清单（如果已生成）
// 2. 在清单中 → 使用 Addressables
// 3. 不在清单中 → 使用 Resources

// 示例
var prefab = await GridFramework.Resource.LoadAsync<GameObject>("Game/UI/Prefabs/main_menu");
// 框架自动判断并选择加载方式
```

### 手动切换（可选）

```csharp
using Framework.Core.Resource;

var center = GridFramework.Resource as ResourceCenter;

// 查看当前模式
Debug.Log($"当前模式: {center.CurrentLoaderType}");
// 输出: Auto（自动）、Resources（强制）、Addressables（强制）

// 切换到自动模式（推荐）
center.CurrentLoaderType = ResourceLoaderType.Auto;

// 强制使用 Resources
center.CurrentLoaderType = ResourceLoaderType.Resources;

// 强制使用 Addressables
center.CurrentLoaderType = ResourceLoaderType.Addressables;
```

---

## ⚠️ 常见注意事项

### 1. 路径大小写敏感

```csharp
// Resources 路径大小写敏感
物理文件：UI/Icons/Gold.png
加载路径："UI/Icons/Gold"  ✅
加载路径："UI/Icons/gold"  ❌ 找不到！

// 建议：统一使用小写
物理文件：UI/Icons/gold.png
加载路径："UI/Icons/gold"  ✅
```

### 2. 不要在 Update 中加载

```csharp
// ❌ 错误：每帧加载资源
void Update()
{
    var prefab = GridFramework.Resource.Load<GameObject>("Prefabs/Bullet");
    Instantiate(prefab);
}

// ✅ 正确：使用对象池
private GameObjectPool _bulletPool;

async void Start()
{
    var prefab = await GridFramework.Resource.LoadAsync<GameObject>("Prefabs/Bullet");
    _bulletPool = GridFramework.Pool.CreateGameObjectPool(prefab, 50);
}

void Update()
{
    var bullet = _bulletPool.Spawn();  // 从池中获取
}
```

### 3. 及时释放资源

```csharp
// ✅ 好的做法
public class UIController : MonoBehaviour
{
    async void OpenShop()
    {
        var shop = await GridFramework.Resource.LoadAsync<GameObject>("UI/Prefabs/Shop");
        Instantiate(shop);
    }
    
    void CloseShop()
    {
        // 关闭时释放资源
        GridFramework.Resource.Release("UI/Prefabs/Shop");
    }
    
    void OnSceneUnload()
    {
        // 场景卸载时释放所有未使用资源
        GridFramework.Resource.ReleaseUnused();
    }
}
```

### 4. 异步加载注意事项

```csharp
// ✅ 正确：使用 await
async void LoadAsset()
{
    var prefab = await GridFramework.Resource.LoadAsync<GameObject>("UI/MainMenu");
    if (prefab != null)
    {
        Instantiate(prefab);
    }
}

// ❌ 错误：忘记 await
async void LoadAsset()
{
    var prefab = GridFramework.Resource.LoadAsync<GameObject>("UI/MainMenu");
    // prefab 是 Task，不是 GameObject！
}

// ❌ 错误：阻塞等待
void LoadAsset()
{
    var task = GridFramework.Resource.LoadAsync<GameObject>("UI/MainMenu");
    task.Wait();  // 阻塞主线程！
}
```

### 5. 生成清单后的操作

```
标记/修改 Addressable 资源后：
1. 重新生成清单（Tools → 生成 Addressable 清单）
2. 重新构建 Addressables（如果需要）
3. 运行测试

不生成清单的后果：
- 新资源会使用试错模式加载
- 性能稍慢，但功能正常
```

### 6. 资源路径与 Address 一致性

```
推荐做法（Resources 和 Addressables 路径一致）：

Resources：
物理位置：Assets/Game/Resources/UI/Icons/gold.png
加载路径："UI/Icons/gold"

Addressables：
物理位置：Assets/AddressableAssets/Game/UI/Prefabs/main_menu.prefab
Address：   "Game/UI/Prefabs/main_menu"
加载路径：   "Game/UI/Prefabs/main_menu"

好处：
- 代码统一清晰
- 便于迁移
- 避免混淆
```

---

## 📦 资源加载

### 同步加载

```csharp
using Framework.Scripts;

// 加载 UI 预制体
var uiPrefab = GridFramework.Resource.Load<GameObject>("UI/Prefabs/MainMenu");

// 加载音频
var audioClip = GridFramework.Resource.Load<AudioClip>("Audio/Music/bgm_main");

// 加载配置
var config = GridFramework.Resource.Load<TextAsset>("Configs/GameConfig");

// 加载纹理
var texture = GridFramework.Resource.Load<Texture2D>("Textures/character_01");
```

### 异步加载（推荐）

```csharp
async void LoadAssets()
{
    // 异步加载
    var uiPrefab = await GridFramework.Resource.LoadAsync<GameObject>("UI/Prefabs/MainMenu");
    
    // 带进度回调
    var scene = await GridFramework.Resource.LoadAsync<GameObject>(
        "Scenes/Level1",
        progress => loadingBar.value = progress
    );
}
```

### 批量预加载

```csharp
async void PreloadLevel()
{
    // 批量预加载关卡资源
    await GridFramework.Resource.PreloadAsync(
        progress => UpdateLoadingUI(progress),
        "UI/Prefabs/BattleHUD",
        "Prefabs/Enemies/Goblin",
        "Prefabs/Effects/Explosion",
        "Audio/Music/bgm_battle"
    );
    
    Debug.Log("关卡资源预加载完成");
}
```

---

## 🗑️ 资源释放

### 释放单个资源

```csharp
void CloseUI()
{
    // 释放指定路径的资源
    GridFramework.Resource.Release("UI/Prefabs/Shop");
}
```

### 释放未使用资源

```csharp
void OnLevelComplete()
{
    // 释放所有引用计数为0的资源
    GridFramework.Resource.ReleaseUnused();
}
```

### 清空所有缓存

```csharp
void OnLowMemory()
{
    // 强制清空所有缓存（慎用）
    GridFramework.Resource.ClearCache();
}
```

---

## 🎮 对象池

### GameObject 对象池

```csharp
using Framework.Modules.Pool;

public class BulletManager : MonoBehaviour
{
    private GameObjectPool _bulletPool;
    
    async void Start()
    {
        // 加载预制体
        var bulletPrefab = await GridFramework.Resource.LoadAsync<GameObject>(
            "Prefabs/Projectiles/Bullet"
        );
        
        // 创建对象池
        _bulletPool = GridFramework.Pool.CreateGameObjectPool(
            bulletPrefab,
            poolName: "BulletPool",
            parent: transform,
            minSize: 20,
            maxSize: 100
        );
    }
    
    void Fire()
    {
        // 从池中获取
        var bullet = _bulletPool.Spawn(firePoint.position, firePoint.rotation);
    }
    
    void OnBulletHit(GameObject bullet)
    {
        // 归还到池
        _bulletPool.Despawn(bullet);
    }
}
```

### 便捷方法

```csharp
public class SimpleExample : MonoBehaviour
{
    [SerializeField] private GameObject effectPrefab;
    
    void PlayEffect()
    {
        // 快捷方式（自动创建池）
        var effect = GridFramework.Pool.Spawn(effectPrefab, transform.position);
        
        // 延迟归还
        StartCoroutine(DespawnAfter(effect, 2f));
    }
    
    IEnumerator DespawnAfter(GameObject obj, float delay)
    {
        yield return new WaitForSeconds(delay);
        GridFramework.Pool.Despawn(obj);
    }
}
```

### 普通对象池

```csharp
using Framework.Modules.Pool;

public class DataManager : MonoBehaviour
{
    private ObjectPool<GameEvent> _eventPool;
    
    void Start()
    {
        // 创建事件对象池
        _eventPool = GridFramework.Pool.CreateObjectPool<GameEvent>(
            createFunc: () => new GameEvent(),
            onReturn: (evt) => evt.Clear(),
            minSize: 10,
            maxSize: 50
        );
    }
    
    void TriggerEvent(string type)
    {
        var evt = _eventPool.Spawn();
        evt.Type = type;
        ProcessEvent(evt);
        _eventPool.Despawn(evt);
    }
}
```

---

## 🔍 资源查询

### 检查资源状态

```csharp
// 检查资源是否已加载
bool isLoaded = GridFramework.Resource.IsLoaded("UI/Prefabs/MainMenu");

// 获取引用计数
int refCount = GridFramework.Resource.GetReferenceCount("UI/Prefabs/MainMenu");

// 获取缓存资源数量
int cacheCount = GridFramework.Resource.CacheCount;
```

---

## 🎯 实战案例

### 案例1：关卡加载

```csharp
public class LevelLoader : MonoBehaviour
{
    async void LoadLevel(int levelId)
    {
        // 显示加载界面
        ShowLoadingScreen();
        
        // 预加载关卡资源
        await GridFramework.Resource.PreloadAsync(
            progress => UpdateLoadingProgress(progress),
            $"Scenes/Level{levelId}",
            "UI/Prefabs/BattleHUD",
            $"Audio/Music/bgm_level{levelId}",
            "Prefabs/Enemies/Goblin",
            "Prefabs/Enemies/Orc"
        );
        
        // 创建对象池
        var enemyPrefab = await GridFramework.Resource.LoadAsync<GameObject>("Prefabs/Enemies/Goblin");
        var enemyPool = GridFramework.Pool.CreateGameObjectPool(enemyPrefab, minSize: 10);
        
        // 隐藏加载界面，开始游戏
        HideLoadingScreen();
        StartLevel();
    }
}
```

### 案例2：UI管理

```csharp
public class UIManager : MonoBehaviour
{
    private Dictionary<string, GameObject> _openUIs = new Dictionary<string, GameObject>();
    
    public async void OpenUI(string uiName)
    {
        // 加载UI预制体
        var uiPrefab = await GridFramework.Resource.LoadAsync<GameObject>($"UI/Prefabs/{uiName}");
        
        // 实例化UI
        var uiInstance = Instantiate(uiPrefab, uiRoot);
        _openUIs[uiName] = uiInstance;
    }
    
    public void CloseUI(string uiName)
    {
        if (_openUIs.TryGetValue(uiName, out var uiInstance))
        {
            Destroy(uiInstance);
            _openUIs.Remove(uiName);
            
            // 释放资源
            GridFramework.Resource.Release($"UI/Prefabs/{uiName}");
        }
    }
}
```

### 案例3：特效管理

```csharp
public class EffectManager : MonoBehaviour
{
    private Dictionary<string, GameObjectPool> _effectPools = 
        new Dictionary<string, GameObjectPool>();
    
    public async void PreloadEffect(string effectName, int poolSize = 10)
    {
        var prefab = await GridFramework.Resource.LoadAsync<GameObject>(
            $"Prefabs/Effects/{effectName}"
        );
        
        var pool = GridFramework.Pool.CreateGameObjectPool(prefab, minSize: poolSize);
        _effectPools[effectName] = pool;
    }
    
    public void PlayEffect(string effectName, Vector3 position)
    {
        if (_effectPools.TryGetValue(effectName, out var pool))
        {
            var effect = pool.Spawn(position);
            StartCoroutine(DespawnAfter(pool, effect, 2f));
        }
    }
    
    IEnumerator DespawnAfter(GameObjectPool pool, GameObject obj, float delay)
    {
        yield return new WaitForSeconds(delay);
        pool.Despawn(obj);
    }
}
```

---

## 🛠️ 编辑器工具

### 生成 Addressable 清单

```
菜单：Tools → 资源管理 → 生成 Addressable 清单

作用：
- 扫描所有 Addressable 资源
- 生成清单文件（Assets/Generations/Resources/AddressableResourceManifest.asset）
- 运行时实现零开销查询（0ms）

使用时机：
- 添加/删除 Addressable 资源后
- 修改资源 Address 后
- 构建前

详见：[资源清单系统使用指南](资源清单系统使用指南.md)
```

---

## 📝 API 速查表

### 资源管理

| 方法 | 说明 |
|------|------|
| `Load<T>(path)` | 同步加载资源 |
| `LoadAsync<T>(path)` | 异步加载资源 |
| `LoadAsync<T>(path, onProgress)` | 异步加载（带进度） |
| `PreloadAsync(paths)` | 批量预加载 |
| `PreloadAsync(onProgress, paths)` | 批量预加载（带进度） |
| `Release(path)` | 释放资源 |
| `ReleaseUnused()` | 释放未使用资源 |
| `ClearCache()` | 清空所有缓存 |
| `IsLoaded(path)` | 检查是否已加载 |
| `GetReferenceCount(path)` | 获取引用计数 |
| `CacheCount` | 缓存资源数量 |

### 对象池

| 方法 | 说明 |
|------|------|
| `CreateGameObjectPool(prefab, minSize, maxSize)` | 创建GameObject池 |
| `CreateObjectPool<T>()` | 创建普通对象池 |
| `Spawn()` | 从池中获取对象 |
| `Despawn(obj)` | 归还对象到池 |
| `PrintStatistics()` | 打印统计信息 |

---

## 💡 使用建议

### 资源加载

- ✅ 优先使用异步加载
- ✅ 使用预加载提升体验
- ✅ 及时释放不用的资源
- ❌ 不要在 Update 中加载资源

### 对象池

- ✅ 频繁创建的对象使用对象池
- ✅ 设置合理的池大小
- ✅ 使用完及时归还
- ❌ 不要忘记归还对象

---

**快速开始使用资源系统和对象池吧！** 🚀

