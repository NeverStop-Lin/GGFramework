# 资源清单系统使用指南

> **版本**: v2.0.0  
> **功能**: Addressable 资源清单生成与使用

---

## 📋 什么是资源清单

资源清单是一个包含所有 Addressable 资源索引的文件，框架通过查询清单快速判断资源位置，自动选择最优加载方式。

**清单文件**：`Assets/Generations/Resources/AddressableResourceManifest.asset`

---

## 🚀 使用步骤

### 步骤1：生成清单

#### 方法1：使用菜单工具（推荐）

```
Unity 编辑器：
Tools → 资源管理 → 生成 Addressable 清单

操作：
1. 点击"生成资源清单"按钮
2. 等待扫描完成
3. 查看生成结果
```

#### 方法2：自动生成

```
Unity 编辑器：
Tools → 资源管理 → 自动生成清单（构建时）
```

### 步骤2：运行时使用

```csharp
// 框架自动加载清单，无需额外代码
// 直接使用资源加载接口即可

var prefab = await GridFramework.Resource.LoadAsync<GameObject>("UI/Prefabs/MainMenu");
// 框架自动查询清单并选择加载方式
```

---

## 🛠️ 清单生成器窗口

### 窗口功能

```
位置：Tools → 资源管理 → 生成 Addressable 清单

功能按钮：
├─ 生成资源清单 - 扫描并生成清单
├─ 查看清单文件 - 在 Project 窗口定位
└─ 清空清单 - 清除清单数据

显示信息：
├─ 清单路径
├─ 最后生成时间
└─ 资源数量
```

### 生成结果

```
生成完成后显示：
- 扫描的资源数量
- 生成时间
- 清单文件路径
```

---

## 📝 清单内容

### 包含信息

清单中每个资源条目包含：

| 字段 | 说明 | 用途 |
|------|------|------|
| `address` | 资源地址 | 运行时查询 |
| `assetType` | 资源类型 | 类型判断 |
| `guid` | 资源GUID | 唯一标识 |
| `physicalPath` | 物理路径 | 调试定位 |
| `groupName` | 所属分组 | 分组管理 |

### 数据示例

```json
{
  "generatedTime": "2024-01-15 10:30:00",
  "totalCount": 150,
  "resources": [
    {
      "address": "Game/UI/Prefabs/main_menu",
      "assetType": "GameObject",
      "guid": "abc123...",
      "physicalPath": "Assets/AddressableAssets/Game/UI/Prefabs/main_menu.prefab",
      "groupName": "UI Group"
    }
  ]
}
```

---

## 💻 代码使用

### 基本使用

```csharp
public class Example : MonoBehaviour
{
    async void Start()
    {
        // 加载资源（框架自动查询清单）
        var ui = await GridFramework.Resource.LoadAsync<GameObject>("Game/UI/Prefabs/main_menu");
        var audio = await GridFramework.Resource.LoadAsync<AudioClip>("Game/Audio/Music/bgm_battle");
        
        // 无需关心资源在 Resources 还是 Addressables
    }
}
```

### 查看清单状态

```csharp
using Framework.Core.Resource;

public class ResourceDebugger : MonoBehaviour
{
    void PrintManifestInfo()
    {
        var center = GridFramework.Resource as ResourceCenter;
        var autoLoader = center.GetLoader(ResourceLoaderType.Auto) as AutoResourceLoader;
        
        if (autoLoader != null)
        {
            Debug.Log($"清单状态: {(autoLoader.ManifestLoaded ? "已加载" : "未加载")}");
            Debug.Log($"清单资源数: {autoLoader.ManifestResourceCount}");
            Debug.Log($"Addressables 可用: {autoLoader.AddressablesAvailable}");
        }
    }
}
```

### 重新加载清单

```csharp
public class ResourceManager : MonoBehaviour
{
    void ReloadManifest()
    {
        var center = GridFramework.Resource as ResourceCenter;
        var autoLoader = center.GetLoader(ResourceLoaderType.Auto) as AutoResourceLoader;
        
        if (autoLoader != null)
        {
            autoLoader.ReloadManifest();
            Debug.Log("清单已重新加载");
        }
    }
}
```

---

## 📊 工作流程

### 开发流程

```
1. 开发阶段
   ├─ 资源放在 Game/Resources/ 或 Game/Art/
   └─ 快速迭代开发

2. 标记 Addressable
   ├─ 选中资源，勾选 "Addressable"
   └─ 设置 Address

3. 生成清单
   ├─ Tools → 生成 Addressable 清单
   └─ 清单文件自动生成

4. 运行测试
   └─ 代码无需修改，自动使用清单
```

### 更新流程

```
添加/删除/修改 Addressable 资源
  ↓
Tools → 生成 Addressable 清单
  ↓
清单自动更新
  ↓
运行时自动生效
```

---

## 📁 文件位置

### 清单文件

```
物理位置：
Assets/Generations/Resources/AddressableResourceManifest.asset

加载路径：
"AddressableResourceManifest"

说明：
- Generations/Resources/ 会被 Unity 识别为 Resources 目录
- 运行时自动加载
- 文件很小（几KB），不影响包体
```

---

## ⚠️ 注意事项

### 1. 及时更新清单

```
何时重新生成？
├─ 添加 Addressable 资源
├─ 删除 Addressable 资源
├─ 修改 Address
└─ 构建前

操作：
Tools → 资源管理 → 生成 Addressable 清单
```

### 2. 版本控制

```
建议提交清单文件到版本控制：
✅ AddressableResourceManifest.asset
✅ AddressableResourceManifest.asset.meta

团队共享清单，保持一致
```

### 3. 降级机制

```
清单加载失败时：
└─ 自动使用试错模式
   ├─ 先尝试 Resources
   └─ 再尝试 Addressables

功能正常，性能稍慢
```

---

## 🎯 实战示例

### 示例1：关卡加载

```csharp
public class LevelLoader : MonoBehaviour
{
    async void LoadLevel(int levelId)
    {
        ShowLoadingScreen();
        
        // 预加载关卡资源（框架自动查询清单）
        await GridFramework.Resource.PreloadAsync(
            progress => UpdateProgress(progress),
            $"Game/Scenes/level_{levelId:D2}",
            "Game/UI/Prefabs/battle_hud",
            $"Game/Audio/Music/bgm_level_{levelId:D2}",
            "Game/3D/Prefabs/Characters/enemy_goblin"
        );
        
        HideLoadingScreen();
        StartLevel();
    }
}
```

### 示例2：UI管理

```csharp
public class UIManager : MonoBehaviour
{
    async void OpenUI(string uiName)
    {
        // 加载UI（自动查询清单）
        var uiPrefab = await GridFramework.Resource.LoadAsync<GameObject>(
            $"Game/UI/Prefabs/{uiName}"
        );
        
        if (uiPrefab != null)
        {
            Instantiate(uiPrefab, uiRoot);
        }
    }
    
    void CloseUI(string uiName)
    {
        // 释放资源
        GridFramework.Resource.Release($"Game/UI/Prefabs/{uiName}");
    }
}
```

### 示例3：音频加载

```csharp
public class AudioManager : MonoBehaviour
{
    async void PlayMusic(string musicName)
    {
        // 加载背景音乐
        var clip = await GridFramework.Resource.LoadAsync<AudioClip>(
            $"Game/Audio/Music/{musicName}"
        );
        
        if (clip != null)
        {
            musicSource.clip = clip;
            musicSource.Play();
        }
    }
    
    async void PlayEffect(string effectName)
    {
        // 加载音效
        var clip = await GridFramework.Resource.LoadAsync<AudioClip>(
            $"Game/Audio/Effects/{effectName}"
        );
        
        if (clip != null)
        {
            AudioSource.PlayClipAtPoint(clip, Camera.main.transform.position);
        }
    }
}
```

---

## 🔍 调试工具

### 查看清单信息

```csharp
[ContextMenu("查看清单信息")]
void PrintManifestInfo()
{
    var center = GridFramework.Resource as ResourceCenter;
    var autoLoader = center.GetLoader(ResourceLoaderType.Auto) as AutoResourceLoader;
    
    if (autoLoader != null)
    {
        Debug.Log("===== 资源清单信息 =====");
        Debug.Log($"清单已加载: {autoLoader.ManifestLoaded}");
        Debug.Log($"清单资源数: {autoLoader.ManifestResourceCount}");
        Debug.Log($"Addressables 可用: {autoLoader.AddressablesAvailable}");
    }
}
```

### 控制台输出

```
[AutoResourceLoader] 自动资源加载器初始化完成
  - Addressables 可用: True
  - 资源清单: 已加载（150 个资源）
  - 查询方式: 清单查询（0ms）⭐⭐⭐

[AutoResourceLoader] 清单命中，使用 Addressables: Game/UI/Prefabs/main_menu
[AutoResourceLoader] ✅ Addressables 加载成功

[AutoResourceLoader] 清单未命中，使用 Resources: UI/Icons/gold
[AutoResourceLoader] ✅ Resources 加载成功
```

---

## 📝 FAQ

### Q1: 清单必须生成吗？

不是必须的，但强烈推荐生成清单以获得最佳性能。

### Q2: 清单多久更新一次？

每次 Addressable 资源变化后重新生成即可。

### Q3: 清单会增加包体吗？

几乎不会，清单文件很小（100个资源约10KB）。

### Q4: 清单加载失败怎么办？

框架会自动降级到试错模式，功能不受影响。

---

## ✅ 使用要点

1. **构建前生成清单** - Tools → 生成 Addressable 清单
2. **清单文件提交版本控制** - 团队共享
3. **代码无需修改** - 框架自动处理
4. **资源变化后重新生成** - 保持清单最新

---

**使用清单系统，实现零开销资源查询！** 🚀
