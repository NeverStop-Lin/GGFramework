# UI系统使用指南

> **版本**: v2.0  
> **更新日期**: 2025-01-26  
> **适用范围**: GGFramework UI系统

---

## 📋 目录

1. [快速开始](#1-快速开始)
2. [标记规范](#2-标记规范)
3. [代码生成](#3-代码生成)
4. [UI配置](#4-ui配置)
5. [数据绑定](#5-数据绑定)
6. [高级功能](#6-高级功能)
7. [常见问题](#7-常见问题)

---

## 1. 快速开始

### 1.1 创建第一个UI（5分钟教程）

#### 步骤1：在Unity中设计UI Prefab

1. 在Unity中创建一个新的Canvas（GameObject -> UI -> Canvas）
2. 设计你的UI界面，添加Button、Text、Image等组件
3. **关键步骤**：给需要绑定的组件添加`@`前缀标记
   ```
   Canvas
     └─ Panel
         ├─ @Button_Start      ← 开始按钮
         ├─ @Button_Settings   ← 设置按钮
         └─ @Text_Title        ← 标题文本
   ```
4. 保存为Prefab：拖拽到 `Assets/Resources/UI/` 目录，命名为 `MainMenu.prefab`

#### 步骤2：生成UI代码

1. 打开生成器：菜单 `Tools -> UI工具 -> 生成UI代码`
2. 点击"添加Prefab"，选择 `MainMenu.prefab`
3. 配置命名空间（如：`Game.UI`）
4. 配置输出路径（如：`Assets/Game/Scripts/UI`）
5. 点击"生成代码"

#### 步骤3：编写业务逻辑

生成器会创建两个文件：
- `MainMenuUI.Binding.cs` - 自动生成，不要修改
- `MainMenuUI.cs` - 业务逻辑，在这里编写代码

打开 `MainMenuUI.cs`：

```csharp
namespace Game.UI
{
    public partial class MainMenuUI
    {
        // 显示时的逻辑
        protected override void OnShow(params object[] args)
        {
            base.OnShow(args);
            
            _titleText.text = "主菜单";  // 自动绑定的字段，直接使用
        }
        
        // 按钮点击事件（自动生成的方法签名）
        private void OnStartClick()
        {
            Hide();
            GridFramework.UI.Show<GameUI>();
        }
        
        private void OnSettingsClick()
        {
            GridFramework.UI.Show<SettingsUI>();
        }
    }
}
```

#### 步骤4：显示UI

在你的游戏代码中：

```csharp
using Game.UI;

public class GameLauncher : MonoBehaviour
{
    void Start()
    {
        // 显示主菜单
        GridFramework.UI.Show<MainMenuUI>();
    }
}
```

✅ 完成！你的第一个UI已经运行了！

---

## 2. 标记规范

### 2.1 支持的组件标记

| 标记格式 | 组件类型 | 生成字段 | 示例 |
|---------|---------|---------|------|
| `@Button_名称` | Button | `_名称Button` | `@Button_Start` → `_startButton` |
| `@Text_名称` | Text | `_名称Text` | `@Text_Title` → `_titleText` |
| `@TextTMP_名称` | TextMeshProUGUI | `_名称Text` | `@TextTMP_Title` → `_titleText` |
| `@Image_名称` | Image | `_名称Image` | `@Image_Icon` → `_iconImage` |
| `@Input_名称` | InputField | `_名称Input` | `@Input_Name` → `_nameInput` |
| `@Toggle_名称` | Toggle | `_名称Toggle` | `@Toggle_Sound` → `_soundToggle` |
| `@Slider_名称` | Slider | `_名称Slider` | `@Slider_Volume` → `_volumeSlider` |
| `@Transform_名称` | Transform | `_名称Transform` | `@Transform_Container` → `_containerTransform` |
| `@GameObject_名称` | GameObject | `_名称GameObject` | `@GameObject_Panel` → `_panelGameObject` |

### 2.2 命名规则

**正确示例**：
```
@Button_Start         ✅ 简单名称
@Button_Close_Panel   ✅ 多单词用下划线分隔
@Text_Player_Name     ✅ 多单词
```

**错误示例**：
```
Button_Start          ❌ 缺少@前缀（不会被识别）
@button_start         ❌ 不符合驼峰规范
@ButtonStart          ❌ 缺少下划线分隔
```

### 2.3 Button自动事件绑定

Button组件会自动生成事件绑定：

```csharp
@Button_Start      → OnStartClick()
@Button_Close      → OnCloseClick()
@Button_Buy_Item   → OnBuyItemClick()
```

你只需要在Logic文件中实现这些方法。

---

## 3. 代码生成

### 3.1 生成器窗口

**打开方式**：
- 菜单：`Tools -> UI工具 -> 生成UI代码`
- 右键Prefab：`生成UI代码`

**功能**：
- 单个Prefab生成
- 批量生成（多选Prefab）
- 目录扫描批量生成

### 3.2 生成的文件

#### Binding.cs（自动生成，每次覆盖）

```csharp
// <auto-generated />
// 警告: 请勿手动修改此文件

public partial class MainMenuUI : UGUIBaseUI
{
    #region Auto-Generated Fields
    private Button _startButton;
    private Text _titleText;
    #endregion
    
    #region Auto-Generated Binding
    protected override void BindComponents()
    {
        base.BindComponents();
        _startButton = FindComponent<Button>("Panel/@Button_Start");
        _titleText = FindComponent<Text>("Panel/@Text_Title");
    }
    #endregion
    
    #region Auto-Generated Events
    protected override void RegisterEvents()
    {
        base.RegisterEvents();
        _startButton.onClick.AddListener(OnStartClick);
    }
    
    protected override void UnregisterEvents()
    {
        _startButton.onClick.RemoveListener(OnStartClick);
        base.UnregisterEvents();
    }
    #endregion
}
```

#### Logic.cs（仅首次生成，可手动修改）

```csharp
namespace Game.UI
{
    public partial class MainMenuUI
    {
        #region UI配置
        protected override UIConfig CreateUIConfig()
        {
            return new UIConfig
            {
                ResourcePath = "UI/MainMenu",
                UIType = UIType.Main,
                CacheStrategy = UICacheStrategy.AlwaysCache
            };
        }
        #endregion
        
        #region 生命周期
        protected override void OnShow(params object[] args)
        {
            base.OnShow(args);
            // TODO: 实现显示逻辑
        }
        #endregion
        
        #region 事件处理
        private void OnStartClick()
        {
            // TODO: 实现点击逻辑
        }
        #endregion
    }
}
```

### 3.3 增量更新

当Prefab改动后：
1. 重新选择Prefab
2. 点击"生成代码"
3. **只更新Binding.cs**，Logic.cs不会被覆盖

---

## 4. UI配置

### 4.1 代码配置

在 `CreateUIConfig()` 中配置：

```csharp
protected override UIConfig CreateUIConfig()
{
    return new UIConfig
    {
        ResourcePath = "UI/MainMenu",        // 资源路径
        UIType = UIType.Main,                 // UI类型
        AlignType = UIAlignType.Center,       // 对齐方式
        CacheStrategy = UICacheStrategy.AlwaysCache,  // 缓存策略
        UseMask = false,                      // 是否使用遮罩
        UseAnimation = true,                  // 是否使用动画
        AnimationType = UIAnimationType.Fade, // 动画类型
        Preload = false                       // 是否预加载
    };
}
```

### 4.2 运行时配置（UIManifest）

在 `Assets/Resources/Config/UIManifest.asset` 中配置：

1. 在Project窗口找到UIManifest
2. 在Inspector中编辑
3. 添加或修改UI配置

**运行时配置优先级高于代码配置！**

### 4.3 配置项说明

| 配置项 | 类型 | 说明 |
|--------|------|------|
| ResourcePath | string | UI资源路径（相对于Resources） |
| UIType | enum | Main/Popup/Top/Effect |
| AlignType | enum | Center/Top/Bottom |
| CacheStrategy | enum | AlwaysCache/NeverCache/LRU |
| UseMask | bool | 是否添加半透明遮罩 |
| UseAnimation | bool | 是否使用显示/隐藏动画 |
| AnimationType | enum | Fade/Scale/Slide/Custom |
| Preload | bool | 是否在启动时预加载 |

---

## 5. 数据绑定

### 5.1 与Observer集成

```csharp
using Framework.Core;

public partial class MainMenuUI
{
    private IValueObserver<int> _goldObserver;
    
    protected override void OnShow(params object[] args)
    {
        base.OnShow(args);
        
        // 创建或获取Observer
        _goldObserver = GridFramework.Observer.Cache("player_gold", 100);
        
        // 绑定到Text（数据变化自动更新UI）
        _goldText.BindNumber(_goldObserver, "金币: {0}");
    }
}
```

### 5.2 绑定扩展方法

| 方法 | 用途 | 示例 |
|------|------|------|
| `BindText()` | 绑定文本 | `_nameText.BindText(nameObserver)` |
| `BindNumber()` | 绑定数字 | `_scoreText.BindNumber(scoreObserver, "分数: {0}")` |
| `BindActive()` | 绑定激活状态 | `_panel.BindActive(visibleObserver)` |
| `BindFillAmount()` | 绑定进度条 | `_progressBar.BindFillAmount(progressObserver)` |
| `BindToggle()` | 绑定Toggle（双向） | `_soundToggle.BindToggle(soundEnabledObserver)` |

---

## 6. 高级功能

### 6.1 UI栈管理

```csharp
// 推入UI栈（支持返回功能）
GridFramework.UI.PushUI<SettingsUI>();

// 返回上一个UI
await GridFramework.UI.PopUI();

// 获取UI栈
var stack = GridFramework.UI.GetUIStack();
```

### 6.2 UI预加载

```csharp
// 在启动时预加载
async void Start()
{
    await GridFramework.UI.PreloadUI<MainMenuUI>();
    await GridFramework.UI.PreloadUI<LoadingUI>();
    
    // 现在显示会非常快
    GridFramework.UI.Show<MainMenuUI>();
}
```

或者在UIManifest中配置 `Preload = true`，启动时自动预加载。

### 6.3 其他API

```csharp
// 销毁UI
await GridFramework.UI.DestroyUI<MainMenuUI>();

// 检查UI是否显示
bool isShowing = GridFramework.UI.IsShowing<MainMenuUI>();

// 获取UI实例
var ui = GridFramework.UI.GetUI<MainMenuUI>();

// 隐藏所有UI（可排除某些）
await GridFramework.UI.HideAll(typeof(LoadingUI));

// 置顶UI
GridFramework.UI.BringToFront<ImportantPopupUI>();
```

---

## 7. 常见问题

### Q1: 找不到组件错误？

**问题**：运行时报错 `找不到组件: @Button_Start`

**原因**：
- Prefab中删除了标记的组件
- 节点名称改变了
- 路径改变了

**解决**：
1. 重新打开Prefab，检查组件是否存在
2. 重新生成代码（会更新路径）

---

### Q2: Logic.cs被覆盖了？

**问题**：手写的代码丢失了

**原因**：不应该在Binding.cs中写代码

**解决**：
- 所有业务逻辑写在 `XXX.cs`（Logic文件）
- 永远不要修改 `XXX.Binding.cs`（Binding文件）

---

### Q3: UI显示不出来？

**检查清单**：
1. ✅ 是否调用了 `GridFramework.UI.Show<XXX>()`
2. ✅ ResourcePath是否正确（相对于Resources）
3. ✅ Prefab是否在Resources目录下
4. ✅ 检查Console是否有错误日志

---

### Q4: 如何添加自定义Attachment？

```csharp
public partial class MainMenuUI
{
    protected override void OnAttachmentInitialize(List<UIAttachment> attachments)
    {
        base.OnAttachmentInitialize(attachments);
        
        // 添加自定义Attachment
        attachments.Add(new MyCustomAttachment());
    }
}
```

---

### Q5: 如何支持多语言？

暂时通过手动实现：

```csharp
protected override void OnShow(params object[] args)
{
    base.OnShow(args);
    
    // 使用多语言系统（如果有）
    _titleText.text = I18n.Get("ui.main.title");
}
```

后续版本会集成多语言支持。

---

## 📌 最佳实践

### ✅ 推荐做法

1. **统一放置资源**
   - UI Prefab：`Assets/Resources/UI/`
   - UI脚本：`Assets/Game/Scripts/UI/`

2. **命名规范**
   - Prefab：`MainMenu.prefab`
   - 类名：`MainMenuUI`（自动添加UI后缀）

3. **配置优先级**
   - 开发阶段：代码配置
   - 调优阶段：UIManifest配置

4. **使用数据绑定**
   - Text、Image等展示组件使用Observer绑定
   - 数据变化自动更新UI

### ❌ 避免的做法

1. **不要手动修改Binding.cs**
2. **不要在构造函数中访问组件**（组件在OnCreate后才绑定）
3. **不要忘记调用base方法**（OnShow、OnHide等）
4. **不要在OnDestroy后访问组件**（已被销毁）

---

## 🎯 工作流程

```
设计Prefab（标记组件）
    ↓
生成代码（工具自动）
    ↓
编写逻辑（OnShow、事件处理）
    ↓
配置属性（UIManifest可选）
    ↓
运行测试（GridFramework.UI.Show）
    ↓
调优（修改配置、重新生成）
```

---

## 📚 延伸阅读

- [UI命名规范](./UI命名规范.md)
- [UI最佳实践](./UI最佳实践.md)
- [开发扩展编码规范](./开发扩展编码规范.md)
- [UI系统重构技术规格书](./UI系统重构技术规格书.md)

---

**文档版本**: v2.0  
**维护者**: GGFramework Team  
**反馈**: 如有问题请联系框架维护者

