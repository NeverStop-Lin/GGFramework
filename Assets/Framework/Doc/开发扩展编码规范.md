# GGFramework 开发扩展编码规范

> **版本**: v2.0.0  
> **更新日期**: 2024-01  
> **适用范围**: GGFramework 核心框架及扩展模块开发

---

## 📋 目录

1. [命名规范](#1-命名规范)
2. [代码结构规范](#2-代码结构规范)
3. [架构设计规范](#3-架构设计规范)
4. [核心系统扩展规范](#4-核心系统扩展规范)
5. [注释和文档规范](#5-注释和文档规范)
6. [最佳实践](#6-最佳实践)
7. [示例代码](#7-示例代码)

---

## 1. 命名规范

### 1.1 类和接口命名

#### 规则
- **类名**: PascalCase（帕斯卡命名法）
- **接口名**: 以 `I` 开头 + PascalCase
- **抽象类**: 以 `Base` 开头（如果是基类）
- **泛型类**: 明确类型参数含义

#### ✅ 正确示例
```csharp
// 类命名
public class SoundModule { }
public class UICenter { }
public class ConfigCenter { }

// 接口命名
public interface IUI { }
public interface IObservers { }
public interface IStorage { }

// 抽象类命名
public abstract class BaseUI { }
public abstract class BaseObserver<T> { }

// 泛型类命名
public class ValueObserver<T> { }  // T 表示值类型
public class CacheObserver<TValue> { }  // TValue 更明确
```

#### ❌ 错误示例
```csharp
// 不要使用下划线或小驼峰
public class sound_module { }
public class uiCenter { }

// 接口不要忘记 I 前缀
public interface UI { }

// 抽象类命名不清晰
public abstract class UIBase { }  // 应该是 BaseUI
```

### 1.2 方法命名

#### 规则
- **公共方法**: PascalCase
- **私有方法**: PascalCase（不使用下划线前缀）
- **生命周期方法**: 以 `On` 开头
- **异步方法**: 以 `Async` 结尾（可选）

#### ✅ 正确示例
```csharp
// 公共方法
public void PlayMusic(string name) { }
public T Get<T>() where T : IConfig { }

// 生命周期方法
protected virtual void OnCreate(params object[] args) { }
protected virtual void OnShow(params object[] args) { }
protected virtual void OnHide(params object[] args) { }
protected virtual void OnDestroy(params object[] args) { }

// 异步方法（两种风格都可以）
public async Task<object> DoCreate(params object[] args) { }
public async Task LoadAssetAsync() { }

// 私有方法
private void ConfigureAudioSource() { }
private object[] GetParameters(PipelineContext context) { }
```

#### ❌ 错误示例
```csharp
// 不要使用小驼峰
public void playMusic() { }

// 不要使用下划线
private void _configure_audio() { }

// 生命周期方法不要遗漏 On 前缀
protected virtual void Create() { }  // 应该是 OnCreate
```

### 1.3 字段和属性命名

#### 规则
- **公共属性**: PascalCase
- **私有字段**: 以 `_` 开头 + camelCase
- **受保护字段**: 以 `_` 开头 + camelCase（可选）
- **常量**: UPPER_SNAKE_CASE 或 PascalCase
- **静态字段**: PascalCase

#### ✅ 正确示例
```csharp
public class SoundModule
{
    // 私有字段：下划线 + 小驼峰
    private AudioSource _audioSource;
    private GameObject _soundObject;
    [Inject] private IObservers _observers;
    
    // 受保护字段
    protected T _value;
    protected UIState _uiState = UIState.None;
    
    // 公共属性：帕斯卡命名
    public bool MusicSwitch { get; set; }
    public T Value { get; set; }
    public UIType UIType { get; set; }
    
    // 静态字段
    public static SoundModule Instance;
    
    // 常量（两种风格都可接受）
    private const int MAX_POOL_SIZE = 100;
    private const string DefaultPath = "Resources/";
}
```

#### ❌ 错误示例
```csharp
// 不要混用命名风格
private AudioSource audioSource;  // 私有字段应该加下划线
public string _name;  // 公共属性不应该有下划线
protected int m_count;  // 不使用 m_ 前缀，使用 _ 前缀
```

### 1.4 命名空间规范

#### 规则
- 遵循目录结构
- 使用公司/项目前缀
- 层次清晰，不超过 4 层

#### ✅ 正确示例
```csharp
namespace Framework.Infrastructure.Core.UI { }
namespace Framework.Infrastructure.Core.Observer { }
namespace Framework.Core.Config { }
namespace Framework.Modules.Sound { }
namespace Framework.Scripts { }
```

### 1.5 特殊命名约定

#### UI 类命名
```csharp
// UI 类以 UI 结尾
public class MainMenuUI : UGUIBaseUI { }
public class SettingsUI : UGUIBaseUI { }
public class GameOverPopupUI : UGUIBaseUI { }

// Attachment 类以 Attachment 结尾
public class MaskUIAttachment : UIAttachment { }
public class AlignUIAttachment : UIAttachment { }
```

#### 模块类命名
```csharp
// 模块类以 Module 结尾
public class SoundModule { }
public class CommonModule { }
public class ReportModule { }
```

#### 观察者类命名
```csharp
// 观察者类以 Observer 结尾
public class ValueObserver<T> : BaseObserver<T> { }
public class CacheObserver<T> : BaseObserver<T> { }
```

---

## 2. 代码结构规范

### 2.1 文件组织

#### 一个文件一个类
```csharp
// ✅ 正确：每个文件只包含一个主要类
// 文件: SoundModule.cs
namespace Framework.Modules.Sound
{
    public class SoundModule
    {
        // ...
    }
}
```

#### 例外：相关的小型类
```csharp
// ✅ 可接受：相关的枚举或小型辅助类可以放在同一文件
// 文件: UIType.cs
namespace Framework.Infrastructure.Core.UI
{
    public enum UIType
    {
        Main,
        Popup,
        Effect,
        Top
    }
    
    public enum UIState
    {
        None,
        Create,
        Show,
        Ready,
        Hide,
        Destroy
    }
}
```

### 2.2 类内部结构顺序

#### 标准顺序（使用 #region 组织）
```csharp
public class ExampleClass : BaseClass
{
    #region 字段
    
    // 1. 常量
    private const int MAX_SIZE = 100;
    
    // 2. 静态字段
    public static ExampleClass Instance;
    
    // 3. 依赖注入字段
    [Inject] private IUI _ui;
    [Inject] private IObservers _observers;
    
    // 4. 私有字段
    private GameObject _gameObject;
    private int _count;
    
    // 5. 受保护字段
    protected UIState _state;
    
    #endregion
    
    #region 属性
    
    // 公共属性
    public int Count { get; set; }
    public bool IsActive { get; private set; }
    
    #endregion
    
    #region 构造函数
    
    public ExampleClass() { }
    
    #endregion
    
    #region 生命周期方法
    
    protected override void OnCreate(params object[] args) { }
    protected override void OnShow(params object[] args) { }
    protected override void OnHide(params object[] args) { }
    protected override void OnDestroy(params object[] args) { }
    
    #endregion
    
    #region 公共方法
    
    public void DoSomething() { }
    
    #endregion
    
    #region 受保护方法
    
    protected virtual void Initialize() { }
    
    #endregion
    
    #region 私有方法
    
    private void UpdateState() { }
    
    #endregion
}
```

### 2.3 命名空间和 Using 语句

#### 规则
1. 按字母顺序排列
2. System 命名空间优先
3. 移除未使用的 using

#### ✅ 正确示例
```csharp
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Framework.Core.Interface;
using Framework.Infrastructure.Core.Observer;
using UnityEngine;
using Zenject;

namespace Framework.Modules.Sound
{
    public class SoundModule
    {
        // ...
    }
}
```

---

## 3. 架构设计规范

### 3.1 依赖注入规范

#### 使用 Zenject 注入依赖

**规则**：
- 使用 `[Inject]` 特性标记依赖
- 优先使用字段注入（简单场景）
- 构造函数注入（需要初始化逻辑）
- 注入接口而非具体实现

#### ✅ 正确示例
```csharp
public class SoundModule
{
    // 字段注入（推荐用于 Unity 组件）
    [Inject] private IObservers _observers;
    [Inject] private IUI _ui;
    
    // 注入接口，不是具体类
    [Inject] private IStorage _storage;  // ✅ 好
    // [Inject] private StorageCenter _storage;  // ❌ 不推荐
    
    public void Initialize()
    {
        // 使用注入的依赖
        var goldObserver = _observers.Value(100);
    }
}
```

#### 构造函数注入示例
```csharp
public class ConfigCenter : IConfigs
{
    private readonly Dictionary<Type, object> _configs;
    
    // 如果需要在构造时初始化
    [Inject]
    public ConfigCenter()
    {
        _configs = new Dictionary<Type, object>();
    }
}
```

### 3.2 接口设计原则

#### 接口隔离原则
- 接口应该小而专注
- 不要创建"胖接口"

#### ✅ 正确示例
```csharp
// 好：每个接口职责单一
public interface IUI
{
    Task<object> Show(Type uiType, params object[] args);
    Task<object> Hide(Type uiType, params object[] args);
}

public interface IObservers
{
    IValueObserver<T> Value<T>(T defaultValue);
    IValueObserver<T> Cache<T>(string key, T defaultValue);
}

public interface IStorage
{
    void Save(string key, object value);
    T Load<T>(string key);
}
```

#### ❌ 错误示例
```csharp
// 不好：接口包含太多不相关的职责
public interface IFramework
{
    void ShowUI();
    void PlaySound();
    void SaveData();
    void LoadConfig();
    // ... 太多职责
}
```

### 3.3 抽象类使用规范

#### 何时使用抽象类
1. 提供默认实现
2. 定义模板方法模式
3. 共享公共代码

#### ✅ 正确示例
```csharp
public abstract class BaseUI : UIAttachment, IBaseUI
{
    // 提供公共字段和属性
    [Inject] protected IUI Center;
    protected UIState uiState = UIState.None;
    public UIType UIType = UIType.Main;
    
    // 提供默认实现
    public void Initialize()
    {
        // 通用初始化逻辑
        OnAttachmentInitialize(_attachments);
    }
    
    // 定义模板方法
    public async Task<object> DoCreate(params object[] args)
    {
        return await ExecuteStatePipelineAsync(UIState.Create, args);
    }
    
    // 子类必须实现的抽象方法
    public abstract int GetIndex();
    public abstract void SetIndex(int i);
    
    // 子类可选重写的虚方法
    protected virtual void OnCreate(params object[] args) { }
    protected virtual void OnShow(params object[] args) { }
}
```

### 3.4 生命周期管理

#### UI 生命周期标准流程
```
Create → Show → Ready → Hide → Destroy
  ↓       ↓              ↓       ↓
初始化   显示UI        准备完成  隐藏    销毁资源
```

#### 实现生命周期
```csharp
public class MyUI : UGUIBaseUI
{
    // 1. Create：创建UI对象
    protected override void CreateUIObject()
    {
        var prefab = Resources.Load<GameObject>("UI/MyUI");
        UIObject = Object.Instantiate(prefab);
    }
    
    // 2. Show：显示UI，接收参数
    protected override void OnShow(params object[] args)
    {
        base.OnShow(args);
        if (args.Length > 0)
        {
            // 处理传入的参数
        }
    }
    
    // 3. Hide：隐藏UI
    protected override void OnHide(params object[] args)
    {
        base.OnHide(args);
        // 清理临时状态
    }
    
    // 4. Destroy：销毁资源
    protected override void OnDestroy(params object[] args)
    {
        // 取消订阅、释放资源
        base.OnDestroy(args);
    }
}
```

---

## 4. 核心系统扩展规范

### 4.1 UI 系统扩展

#### 创建自定义 UI 类

**基本步骤**：
1. 继承 `UGUIBaseUI`
2. 实现 `CreateUIObject()` 方法
3. 重写需要的生命周期方法

#### 完整示例
```csharp
using Framework.Infrastructure.Core.UI;
using UnityEngine;
using UnityEngine.UI;

namespace MyProject.UI
{
    /// <summary>
    /// 主菜单UI
    /// </summary>
    public class MainMenuUI : UGUIBaseUI
    {
        // UI组件引用
        private Button _startButton;
        private Button _settingsButton;
        private Text _titleText;
        
        /// <summary>
        /// 创建UI对象（从Resources加载预制体）
        /// </summary>
        protected override void CreateUIObject()
        {
            // 方式1：从 Resources 加载
            var prefab = Resources.Load<GameObject>("UI/MainMenu");
            UIObject = Object.Instantiate(prefab);
            
            // 方式2：从 Addressables 加载（推荐）
            // var handle = Addressables.LoadAssetAsync<GameObject>("UI/MainMenu");
            // await handle.Task;
            // UIObject = Object.Instantiate(handle.Result);
            
            // 获取组件引用
            _startButton = UIObject.transform.Find("StartButton").GetComponent<Button>();
            _settingsButton = UIObject.transform.Find("SettingsButton").GetComponent<Button>();
            _titleText = UIObject.transform.Find("Title").GetComponent<Text>();
        }
        
        /// <summary>
        /// 显示UI时的逻辑
        /// </summary>
        protected override void OnShow(params object[] args)
        {
            base.OnShow(args);
            
            // 绑定按钮事件
            _startButton.onClick.AddListener(OnStartButtonClick);
            _settingsButton.onClick.AddListener(OnSettingsButtonClick);
            
            // 播放显示动画
            // DOTween.To(() => 0f, x => Canvas.alpha = x, 1f, 0.3f);
        }
        
        /// <summary>
        /// 隐藏UI时的逻辑
        /// </summary>
        protected override void OnHide(params object[] args)
        {
            base.OnHide(args);
            
            // 移除按钮事件监听
            _startButton.onClick.RemoveListener(OnStartButtonClick);
            _settingsButton.onClick.RemoveListener(OnSettingsButtonClick);
        }
        
        /// <summary>
        /// 开始按钮点击
        /// </summary>
        private void OnStartButtonClick()
        {
            // 隐藏当前UI
            Hide();
            
            // 显示游戏UI
            GridFramework.UI.Show<GameUI>();
        }
        
        /// <summary>
        /// 设置按钮点击
        /// </summary>
        private void OnSettingsButtonClick()
        {
            GridFramework.UI.Show<SettingsUI>();
        }
    }
}
```

#### UI 类型定义

```csharp
public class MyMainUI : UGUIBaseUI
{
    public MyMainUI()
    {
        // 设置UI类型
        UIType = UIType.Main;  // 主界面（全屏）
        AlignType = UIAlignType.Center;  // 居中对齐
    }
}

public class MyPopupUI : UGUIBaseUI
{
    public MyPopupUI()
    {
        UIType = UIType.Popup;  // 弹窗
        AlignType = UIAlignType.Center;
    }
}
```

### 4.2 观察者系统扩展

#### 使用内置观察者

```csharp
public class PlayerDataManager
{
    [Inject] private IObservers _observers;
    
    private IValueObserver<int> _goldObserver;
    private IValueObserver<int> _levelObserver;
    
    public void Initialize()
    {
        // 值观察者（不持久化）
        _goldObserver = _observers.Value(0);
        
        // 缓存观察者（持久化到本地）
        _levelObserver = _observers.Cache("player_level", 1);
        
        // 监听变化
        _goldObserver.OnChange.Add((newValue, oldValue) =>
        {
            Debug.Log($"金币变化: {oldValue} -> {newValue}");
            UpdateGoldUI(newValue);
        });
    }
    
    public void AddGold(int amount)
    {
        // 修改值会自动触发监听器
        _goldObserver.Value += amount;
    }
}
```

#### 创建自定义观察者

```csharp
using Framework.Infrastructure.Core.Observer;
using Framework.Core.Interface.Observer;

namespace MyProject.Data
{
    /// <summary>
    /// 自定义观察者：带有验证逻辑的观察者
    /// </summary>
    public class ValidatedObserver<T> : BaseObserver<T>, IValueObserver<T>
    {
        private T _value;
        private readonly Func<T, bool> _validator;
        
        public T Value
        {
            get => _value;
            set
            {
                // 验证新值
                if (_validator != null && !_validator(value))
                {
                    Debug.LogWarning($"值验证失败: {value}");
                    return;
                }
                
                T oldValue = _value;
                _value = value;
                Notify(_value, oldValue);
            }
        }
        
        public ValidatedObserver(T defaultValue, Func<T, bool> validator)
        {
            _value = defaultValue;
            _validator = validator;
        }
        
        public void Initialize(T value)
        {
            _value = value;
            OnChange.AutoInvoke(() => new object[] { Value, Value });
        }
    }
}
```

### 4.3 模块系统扩展

#### 创建自定义模块

**步骤**：
1. 创建模块类
2. 在 `ModuleInstaller.cs` 中注册
3. 在 `GridModules.cs` 中暴露访问接口

#### 完整示例：创建一个网络模块

**步骤 1：创建模块类**
```csharp
using System;
using System.Threading.Tasks;
using Framework.Core.Interface;
using UnityEngine;
using UnityEngine.Networking;
using Zenject;

namespace Framework.Modules.Network
{
    /// <summary>
    /// 网络请求模块
    /// </summary>
    public class NetworkModule
    {
        [Inject] private IObservers _observers;
        
        private string _baseUrl = "https://api.example.com";
        private IValueObserver<bool> _isConnected;
        
        /// <summary>
        /// 是否已连接
        /// </summary>
        public bool IsConnected
        {
            get
            {
                if (_isConnected == null)
                {
                    _isConnected = _observers.Value(true);
                }
                return _isConnected.Value;
            }
            private set => _isConnected.Value = value;
        }
        
        /// <summary>
        /// 发送 GET 请求
        /// </summary>
        public async Task<string> GetAsync(string endpoint)
        {
            string url = $"{_baseUrl}/{endpoint}";
            
            using (UnityWebRequest request = UnityWebRequest.Get(url))
            {
                await request.SendWebRequest();
                
                if (request.result == UnityWebRequest.Result.Success)
                {
                    return request.downloadHandler.text;
                }
                else
                {
                    Debug.LogError($"请求失败: {request.error}");
                    return null;
                }
            }
        }
        
        /// <summary>
        /// 发送 POST 请求
        /// </summary>
        public async Task<string> PostAsync(string endpoint, string jsonData)
        {
            string url = $"{_baseUrl}/{endpoint}";
            
            using (UnityWebRequest request = new UnityWebRequest(url, "POST"))
            {
                byte[] bodyRaw = System.Text.Encoding.UTF8.GetBytes(jsonData);
                request.uploadHandler = new UploadHandlerRaw(bodyRaw);
                request.downloadHandler = new DownloadHandlerBuffer();
                request.SetRequestHeader("Content-Type", "application/json");
                
                await request.SendWebRequest();
                
                if (request.result == UnityWebRequest.Result.Success)
                {
                    return request.downloadHandler.text;
                }
                else
                {
                    Debug.LogError($"请求失败: {request.error}");
                    return null;
                }
            }
        }
    }
}
```

**步骤 2：在 ModuleInstaller 中注册**
```csharp
using Framework.Modules.Sound;
using Framework.Modules.Network;  // 添加引用
using UnityEngine;
using Zenject;

[CreateAssetMenu(fileName = "ModuleInstaller", menuName = "Installers/ModuleInstaller")]
public class ModuleInstaller : ScriptableObjectInstaller<ModuleInstaller>
{
    public override void InstallBindings()
    {
        Container.Bind<SoundModule>().AsSingle();
        Container.Bind<NetworkModule>().AsSingle();  // 注册模块
    }
}
```

**步骤 3：在 GridModules 中暴露**
```csharp
using Framework.Modules.Sound;
using Framework.Modules.Network;  // 添加引用
using UnityEngine;
using Zenject;

namespace Framework.Scripts
{
    public class GridModules : MonoBehaviour
    {
        public static GridModules Instance;
        
        public static SoundModule Sound => Instance._sound;
        public static NetworkModule Network => Instance._network;  // 暴露接口
        
        [Inject] private SoundModule _sound;
        [Inject] private NetworkModule _network;  // 注入模块
        
        void Awake() { Instance = this; }
    }
}
```

**步骤 4：使用模块**
```csharp
public class GameController : MonoBehaviour
{
    async void Start()
    {
        // 使用网络模块
        string response = await GridModules.Network.GetAsync("users/profile");
        Debug.Log($"服务器响应: {response}");
    }
}
```

### 4.4 Attachment 系统扩展

#### 创建自定义 UI Attachment

Attachment 用于为 UI 添加可重用的行为（如动画、遮罩、对齐等）。

#### 示例：创建 UI 动画 Attachment

```csharp
using System.Threading.Tasks;
using Framework.Infrastructure.Core.UI.Attachment;
using Framework.Core.Utils.Pipeline;
using UnityEngine;
using DG.Tweening;  // 需要 DOTween 插件

namespace MyProject.UI.Attachment
{
    /// <summary>
    /// UI显示/隐藏动画附件
    /// 使用 DOTween 实现淡入淡出效果
    /// </summary>
    public class FadeAnimationAttachment : UIAttachment
    {
        private float _duration = 0.3f;
        private CanvasGroup _canvasGroup;
        
        /// <summary>
        /// 显示前：播放淡入动画
        /// </summary>
        protected override async Task OnBeforeShow(PipelineContext context)
        {
            EnsureCanvasGroup();
            
            // 从透明淡入
            _canvasGroup.alpha = 0f;
            await _canvasGroup.DOFade(1f, _duration).AsyncWaitForCompletion();
        }
        
        /// <summary>
        /// 隐藏前：播放淡出动画
        /// </summary>
        protected override async Task OnBeforeHide(PipelineContext context)
        {
            EnsureCanvasGroup();
            
            // 淡出到透明
            await _canvasGroup.DOFade(0f, _duration).AsyncWaitForCompletion();
        }
        
        /// <summary>
        /// 确保有 CanvasGroup 组件
        /// </summary>
        private void EnsureCanvasGroup()
        {
            if (_canvasGroup == null)
            {
                var ui = Target as UGUIBaseUI;
                if (ui != null && ui.Canvas != null)
                {
                    _canvasGroup = ui.Canvas.gameObject.GetComponent<CanvasGroup>();
                    if (_canvasGroup == null)
                    {
                        _canvasGroup = ui.Canvas.gameObject.AddComponent<CanvasGroup>();
                    }
                }
            }
        }
    }
}
```

#### 在 UI 中使用 Attachment

```csharp
using System.Collections.Generic;
using Framework.Infrastructure.Core.UI;
using Framework.Infrastructure.Core.UI.Attachment;
using MyProject.UI.Attachment;

public class MyAnimatedUI : UGUIBaseUI
{
    /// <summary>
    /// 添加自定义 Attachment
    /// </summary>
    protected override void OnAttachmentInitialize(List<UIAttachment> attachments)
    {
        base.OnAttachmentInitialize(attachments);
        
        // 添加淡入淡出动画
        attachments.Add(new FadeAnimationAttachment());
        
        // 可以添加多个 Attachment
        // attachments.Add(new ScaleAnimationAttachment());
        // attachments.Add(new CustomMaskAttachment());
    }
    
    protected override void CreateUIObject()
    {
        var prefab = Resources.Load<GameObject>("UI/MyAnimatedUI");
        UIObject = Object.Instantiate(prefab);
    }
}
```

---

## 5. 注释和文档规范

### 5.1 XML 文档注释

#### 公共 API 必须添加注释

```csharp
/// <summary>
/// 音效管理模块
/// 提供背景音乐和音效的播放功能
/// </summary>
public class SoundModule
{
    /// <summary>
    /// 播放背景音乐
    /// </summary>
    /// <param name="name">音乐文件名（不含扩展名）</param>
    /// <remarks>
    /// 音乐文件应放置在 Resources/Sound/ 目录下
    /// </remarks>
    /// <example>
    /// <code>
    /// GridModules.Sound.PlayMusic("bgm_main");
    /// </code>
    /// </example>
    public void PlayMusic(string name)
    {
        var clip = Resources.Load<AudioClip>($"Sound/{name}");
        PlayMusic(clip);
    }
    
    /// <summary>
    /// 播放音效
    /// </summary>
    /// <param name="clip">音效剪辑</param>
    public void PlayEffect(AudioClip clip)
    {
        if (!EffectSwitch) return;
        _audioSource.PlayOneShot(clip);
    }
}
```

#### 注释标签使用指南

```csharp
/// <summary>类或方法的简要说明</summary>
/// <param name="参数名">参数说明</param>
/// <returns>返回值说明</returns>
/// <exception cref="异常类型">异常说明</exception>
/// <remarks>备注信息（详细说明）</remarks>
/// <example>使用示例</example>
/// <seealso cref="相关类或方法"/>
```

### 5.2 代码注释规范

#### 复杂逻辑必须注释

```csharp
public async Task<object> DoCreate(params object[] args)
{
    // 创建管道上下文，传递参数和目标对象
    var context = new PipelineContext
    {
        Data =
        {
            ["params"] = args,
            ["target"] = this
        }
    };
    
    // 保存上下文以供后续使用
    _pipelineContext[UIState.Create] = context;
    
    // 执行创建管道中的所有中间件
    if (_uiPipelines.TryGetValue(UIState.Create, out var pipeline))
    {
        await pipeline.ExecuteAsync(context);
    }
    
    return context.Result;
}
```

#### 区域标记使用

```csharp
public class MyClass
{
    #region 字段
    
    private int _count;
    
    #endregion
    
    #region 属性
    
    public int Count { get; set; }
    
    #endregion
    
    #region 公共方法
    
    public void DoSomething() { }
    
    #endregion
    
    #region 私有方法
    
    private void Initialize() { }
    
    #endregion
}
```

### 5.3 TODO 注释

```csharp
// TODO: 添加资源缓存机制
// FIXME: 修复内存泄漏问题
// HACK: 临时解决方案，需要重构
// NOTE: 注意这里的执行顺序很重要
```

---

## 6. 最佳实践

### 6.1 async/await 使用规范

#### 规则
1. 异步方法返回 `Task` 或 `Task<T>`
2. 使用 `await` 等待异步操作
3. 避免 `async void`（除了事件处理）
4. 使用 `ConfigureAwait(false)` （非 Unity 主线程）

#### ✅ 正确示例
```csharp
// 异步加载资源
public async Task<GameObject> LoadUIAsync(string path)
{
    var handle = Addressables.LoadAssetAsync<GameObject>(path);
    await handle.Task;
    return handle.Result;
}

// 异步执行管道
private async Task<object> ExecuteStatePipelineAsync(UIState state, object[] args)
{
    var context = new PipelineContext { /* ... */ };
    
    if (_uiPipelines.TryGetValue(state, out var pipeline))
    {
        await pipeline.ExecuteAsync(context);
    }
    
    return context.Result;
}

// 使用异步方法
public async void Start()  // Unity 生命周期方法可以是 async void
{
    await LoadUIAsync("UI/MainMenu");
}
```

#### ❌ 错误示例
```csharp
// 不要阻塞异步方法
public void LoadUI()
{
    var task = LoadUIAsync("UI/MainMenu");
    task.Wait();  // ❌ 会阻塞主线程
}

// 不要忘记 await
public async Task DoSomething()
{
    LoadUIAsync("UI/MainMenu");  // ❌ 忘记 await，方法不会等待完成
}
```

### 6.2 Pipeline 模式使用

Pipeline 模式用于实现可扩展的生命周期管理。

#### 理解 Pipeline

```
请求 → 中间件1 → 中间件2 → 中间件3 → 响应
        ↓          ↓          ↓
      Before     Before     Before
        ↓          ↓          ↓
      After      After      After
```

#### 使用示例

```csharp
// 创建管道
var pipeline = new AsyncPipeline();

// 添加中间件
pipeline.AddMiddleware(async (context, next) =>
{
    Debug.Log("Before step 1");
    await next();
    Debug.Log("After step 1");
});

pipeline.AddMiddleware(async (context, next) =>
{
    Debug.Log("Before step 2");
    await next();
    Debug.Log("After step 2");
});

// 执行管道
await pipeline.ExecuteAsync(new PipelineContext());

// 输出顺序：
// Before step 1
// Before step 2
// After step 2
// After step 1
```

### 6.3 资源管理

#### 使用 Addressables（推荐）

```csharp
using UnityEngine.AddressableAssets;
using UnityEngine.ResourceManagement.AsyncOperations;

public class ResourceManager
{
    // 加载资源
    public async Task<T> LoadAssetAsync<T>(string address) where T : Object
    {
        var handle = Addressables.LoadAssetAsync<T>(address);
        await handle.Task;
        
        if (handle.Status == AsyncOperationStatus.Succeeded)
        {
            return handle.Result;
        }
        
        Debug.LogError($"资源加载失败: {address}");
        return null;
    }
    
    // 释放资源
    public void ReleaseAsset(Object asset)
    {
        Addressables.Release(asset);
    }
}
```

#### Resources 加载（简单场景）

```csharp
public class SimpleResourceLoader
{
    // 同步加载
    public T Load<T>(string path) where T : Object
    {
        return Resources.Load<T>(path);
    }
    
    // 异步加载
    public async Task<T> LoadAsync<T>(string path) where T : Object
    {
        var request = Resources.LoadAsync<T>(path);
        
        while (!request.isDone)
        {
            await Task.Yield();
        }
        
        return request.asset as T;
    }
}
```

### 6.4 性能优化

#### 对象池模式

```csharp
using System.Collections.Generic;
using UnityEngine;

public class ObjectPool<T> where T : Component
{
    private readonly T _prefab;
    private readonly Queue<T> _pool = new Queue<T>();
    private readonly Transform _parent;
    
    public ObjectPool(T prefab, int initialSize = 10, Transform parent = null)
    {
        _prefab = prefab;
        _parent = parent;
        
        // 预创建对象
        for (int i = 0; i < initialSize; i++)
        {
            var obj = Object.Instantiate(_prefab, _parent);
            obj.gameObject.SetActive(false);
            _pool.Enqueue(obj);
        }
    }
    
    /// <summary>
    /// 从池中获取对象
    /// </summary>
    public T Get()
    {
        T obj;
        
        if (_pool.Count > 0)
        {
            obj = _pool.Dequeue();
        }
        else
        {
            obj = Object.Instantiate(_prefab, _parent);
        }
        
        obj.gameObject.SetActive(true);
        return obj;
    }
    
    /// <summary>
    /// 归还对象到池中
    /// </summary>
    public void Return(T obj)
    {
        obj.gameObject.SetActive(false);
        _pool.Enqueue(obj);
    }
}
```

#### 避免频繁的 GetComponent

```csharp
// ❌ 不好：每次都调用 GetComponent
void Update()
{
    GetComponent<Rigidbody>().velocity = Vector3.forward;
}

// ✅ 好：缓存组件引用
private Rigidbody _rigidbody;

void Start()
{
    _rigidbody = GetComponent<Rigidbody>();
}

void Update()
{
    _rigidbody.velocity = Vector3.forward;
}
```

#### 使用 StringBuilder 拼接字符串

```csharp
using System.Text;

// ❌ 不好：频繁字符串拼接
string result = "";
for (int i = 0; i < 1000; i++)
{
    result += i.ToString();
}

// ✅ 好：使用 StringBuilder
var sb = new StringBuilder();
for (int i = 0; i < 1000; i++)
{
    sb.Append(i);
}
string result = sb.ToString();
```

---

## 7. 示例代码

### 7.1 完整的 UI 扩展示例

这是一个完整的商店 UI 实现示例，展示了最佳实践。

```csharp
using System.Collections.Generic;
using Framework.Infrastructure.Core.UI;
using Framework.Infrastructure.Core.UI.Attachment;
using Framework.Core.Interface;
using UnityEngine;
using UnityEngine.UI;
using Zenject;

namespace MyProject.UI
{
    /// <summary>
    /// 商店UI
    /// 展示商品列表，支持购买功能
    /// </summary>
    public class ShopUI : UGUIBaseUI
    {
        #region 依赖注入
        
        [Inject] private IObservers _observers;
        [Inject] private IConfigs _configs;
        
        #endregion
        
        #region UI组件
        
        private Button _closeButton;
        private Button _refreshButton;
        private Transform _itemContainer;
        private Text _goldText;
        
        #endregion
        
        #region 数据
        
        private IValueObserver<int> _goldObserver;
        private List<ShopItemConfig> _shopItems;
        
        #endregion
        
        #region 构造函数
        
        public ShopUI()
        {
            UIType = UIType.Popup;  // 弹窗类型
            AlignType = UIAlignType.Center;  // 居中显示
        }
        
        #endregion
        
        #region 生命周期
        
        /// <summary>
        /// 创建UI对象
        /// </summary>
        protected override void CreateUIObject()
        {
            // 加载预制体
            var prefab = Resources.Load<GameObject>("UI/ShopUI");
            UIObject = Object.Instantiate(prefab);
            
            // 获取UI组件引用
            _closeButton = UIObject.transform.Find("CloseButton").GetComponent<Button>();
            _refreshButton = UIObject.transform.Find("RefreshButton").GetComponent<Button>();
            _itemContainer = UIObject.transform.Find("ItemContainer");
            _goldText = UIObject.transform.Find("GoldText").GetComponent<Text>();
        }
        
        /// <summary>
        /// 显示UI
        /// </summary>
        protected override void OnShow(params object[] args)
        {
            base.OnShow(args);
            
            // 初始化数据
            InitializeData();
            
            // 绑定事件
            _closeButton.onClick.AddListener(OnCloseButtonClick);
            _refreshButton.onClick.AddListener(OnRefreshButtonClick);
            
            // 更新UI
            RefreshShopItems();
            UpdateGoldDisplay();
        }
        
        /// <summary>
        /// 隐藏UI
        /// </summary>
        protected override void OnHide(params object[] args)
        {
            base.OnHide(args);
            
            // 移除事件监听
            _closeButton.onClick.RemoveListener(OnCloseButtonClick);
            _refreshButton.onClick.RemoveListener(OnRefreshButtonClick);
        }
        
        /// <summary>
        /// 销毁UI
        /// </summary>
        protected override void OnDestroy(params object[] args)
        {
            // 取消观察者订阅
            if (_goldObserver != null)
            {
                _goldObserver.OnChange.Clear();
            }
            
            base.OnDestroy(args);
        }
        
        #endregion
        
        #region 私有方法
        
        /// <summary>
        /// 初始化数据
        /// </summary>
        private void InitializeData()
        {
            // 获取金币观察者
            _goldObserver = _observers.Cache("player_gold", 0);
            
            // 监听金币变化
            _goldObserver.OnChange.Add((newValue, oldValue) =>
            {
                UpdateGoldDisplay();
            });
            
            // 加载商店配置
            // var shopConfig = _configs.Get<ShopConfig>();
            // _shopItems = shopConfig.Items;
            
            // 临时数据
            _shopItems = new List<ShopItemConfig>();
        }
        
        /// <summary>
        /// 刷新商店商品列表
        /// </summary>
        private void RefreshShopItems()
        {
            // 清空现有商品
            foreach (Transform child in _itemContainer)
            {
                Object.Destroy(child.gameObject);
            }
            
            // 创建商品UI
            foreach (var item in _shopItems)
            {
                CreateShopItem(item);
            }
        }
        
        /// <summary>
        /// 创建单个商品UI
        /// </summary>
        private void CreateShopItem(ShopItemConfig config)
        {
            var itemPrefab = Resources.Load<GameObject>("UI/ShopItem");
            var itemObj = Object.Instantiate(itemPrefab, _itemContainer);
            
            // 设置商品信息
            var itemUI = itemObj.GetComponent<ShopItemUI>();
            itemUI.SetData(config);
            
            // 绑定购买按钮
            itemUI.OnBuyClick = () => OnBuyItem(config);
        }
        
        /// <summary>
        /// 更新金币显示
        /// </summary>
        private void UpdateGoldDisplay()
        {
            _goldText.text = $"金币: {_goldObserver.Value}";
        }
        
        #endregion
        
        #region 事件处理
        
        /// <summary>
        /// 关闭按钮点击
        /// </summary>
        private void OnCloseButtonClick()
        {
            Hide();
        }
        
        /// <summary>
        /// 刷新按钮点击
        /// </summary>
        private void OnRefreshButtonClick()
        {
            RefreshShopItems();
        }
        
        /// <summary>
        /// 购买商品
        /// </summary>
        private void OnBuyItem(ShopItemConfig item)
        {
            // 检查金币是否足够
            if (_goldObserver.Value < item.Price)
            {
                Debug.Log("金币不足");
                // 显示提示
                return;
            }
            
            // 扣除金币
            _goldObserver.Value -= item.Price;
            
            // 添加物品到背包
            // GridModules.Inventory.AddItem(item.ItemId, item.Count);
            
            Debug.Log($"购买成功: {item.Name}");
        }
        
        #endregion
        
        #region 添加自定义 Attachment
        
        protected override void OnAttachmentInitialize(List<UIAttachment> attachments)
        {
            base.OnAttachmentInitialize(attachments);
            
            // 添加遮罩（点击背景关闭）
            attachments.Add(new MaskUIAttachment());
            
            // 可以添加更多 Attachment
            // attachments.Add(new FadeAnimationAttachment());
        }
        
        #endregion
    }
    
    #region 辅助类
    
    /// <summary>
    /// 商店商品配置
    /// </summary>
    public class ShopItemConfig
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public int Price { get; set; }
        public int ItemId { get; set; }
        public int Count { get; set; }
    }
    
    /// <summary>
    /// 商店商品UI组件
    /// </summary>
    public class ShopItemUI : MonoBehaviour
    {
        public System.Action OnBuyClick;
        
        private Text _nameText;
        private Text _priceText;
        private Button _buyButton;
        
        void Awake()
        {
            _nameText = transform.Find("Name").GetComponent<Text>();
            _priceText = transform.Find("Price").GetComponent<Text>();
            _buyButton = transform.Find("BuyButton").GetComponent<Button>();
            
            _buyButton.onClick.AddListener(() => OnBuyClick?.Invoke());
        }
        
        public void SetData(ShopItemConfig config)
        {
            _nameText.text = config.Name;
            _priceText.text = config.Price.ToString();
        }
    }
    
    #endregion
}
```

### 7.2 完整的模块扩展示例

这是一个完整的数据分析模块示例。

```csharp
using System;
using System.Collections.Generic;
using Framework.Core.Interface;
using UnityEngine;
using Zenject;

namespace Framework.Modules.Analytics
{
    /// <summary>
    /// 数据分析模块
    /// 用于记录和上报游戏事件
    /// </summary>
    public class AnalyticsModule
    {
        #region 依赖注入
        
        [Inject] private IStorage _storage;
        
        #endregion
        
        #region 字段
        
        private readonly Dictionary<string, int> _eventCounts = new Dictionary<string, int>();
        private bool _isEnabled = true;
        
        #endregion
        
        #region 属性
        
        /// <summary>
        /// 是否启用数据统计
        /// </summary>
        public bool IsEnabled
        {
            get => _isEnabled;
            set => _isEnabled = value;
        }
        
        #endregion
        
        #region 构造函数
        
        public AnalyticsModule()
        {
            LoadEventCounts();
        }
        
        #endregion
        
        #region 公共方法
        
        /// <summary>
        /// 记录事件
        /// </summary>
        /// <param name="eventName">事件名称</param>
        /// <param name="parameters">事件参数</param>
        public void TrackEvent(string eventName, Dictionary<string, object> parameters = null)
        {
            if (!_isEnabled) return;
            
            Debug.Log($"[Analytics] 事件: {eventName}");
            
            // 记录事件次数
            if (!_eventCounts.ContainsKey(eventName))
            {
                _eventCounts[eventName] = 0;
            }
            _eventCounts[eventName]++;
            
            // 保存到本地
            SaveEventCounts();
            
            // 上报到服务器
            // SendToServer(eventName, parameters);
        }
        
        /// <summary>
        /// 记录屏幕访问
        /// </summary>
        public void TrackScreen(string screenName)
        {
            TrackEvent($"screen_view", new Dictionary<string, object>
            {
                { "screen_name", screenName }
            });
        }
        
        /// <summary>
        /// 获取事件触发次数
        /// </summary>
        public int GetEventCount(string eventName)
        {
            return _eventCounts.TryGetValue(eventName, out var count) ? count : 0;
        }
        
        /// <summary>
        /// 清空统计数据
        /// </summary>
        public void ClearData()
        {
            _eventCounts.Clear();
            SaveEventCounts();
        }
        
        #endregion
        
        #region 私有方法
        
        /// <summary>
        /// 加载事件计数
        /// </summary>
        private void LoadEventCounts()
        {
            // 从本地存储加载
            var data = _storage.Load<Dictionary<string, int>>("analytics_events");
            if (data != null)
            {
                foreach (var kvp in data)
                {
                    _eventCounts[kvp.Key] = kvp.Value;
                }
            }
        }
        
        /// <summary>
        /// 保存事件计数
        /// </summary>
        private void SaveEventCounts()
        {
            _storage.Save("analytics_events", _eventCounts);
        }
        
        #endregion
    }
}
```

### 7.3 配置系统扩展示例

```csharp
using Framework.Core.Config;
using Framework.Core.Interface.Config;
using System.Collections.Generic;

namespace MyProject.Config
{
    /// <summary>
    /// 商店配置
    /// </summary>
    public class ShopConfig : BaseConfig, IConfig
    {
        /// <summary>
        /// 商店商品列表
        /// </summary>
        public List<ShopItemData> Items { get; set; }
        
        /// <summary>
        /// 刷新时间（秒）
        /// </summary>
        public int RefreshTime { get; set; }
        
        /// <summary>
        /// 加载配置
        /// </summary>
        public void Load()
        {
            // 从 Excel 或 JSON 加载配置
            Items = new List<ShopItemData>
            {
                new ShopItemData { Id = 1, Name = "金币包", Price = 100 },
                new ShopItemData { Id = 2, Name = "宝石包", Price = 500 }
            };
            
            RefreshTime = 3600;
        }
    }
    
    /// <summary>
    /// 商店商品数据
    /// </summary>
    public class ShopItemData
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public int Price { get; set; }
    }
}
```

---

## 📌 快速参考

### 常用代码片段

#### 显示 UI
```csharp
GridFramework.UI.Show<MyUI>();
GridFramework.UI.Show<MyUI>("param1", 123);
```

#### 使用观察者
```csharp
var observer = GridFramework.Observer.Value(100);
observer.OnChange.Add((newVal, oldVal) => Debug.Log(newVal));
observer.Value = 200;
```

#### 播放音效
```csharp
GridModules.Sound.PlayMusic("bgm_main");
GridModules.Sound.PlayEffect("click");
```

#### 读取配置
```csharp
var config = GridFramework.Config.Get<MyConfig>();
```

#### 本地存储
```csharp
GridFramework.Storage.Save("key", value);
var data = GridFramework.Storage.Load<int>("key");
```

#### 资源管理
```csharp
// 同步加载
var prefab = GridFramework.Resource.Load<GameObject>("UI/MainMenu");

// 异步加载
var prefab = await GridFramework.Resource.LoadAsync<GameObject>("UI/MainMenu");

// 带进度加载
var prefab = await GridFramework.Resource.LoadAsync<GameObject>(
    "UI/MainMenu",
    progress => Debug.Log($"加载进度: {progress * 100}%")
);

// 释放资源
GridFramework.Resource.Release("UI/MainMenu");
```

#### 对象池
```csharp
// 创建对象池
var pool = GridFramework.Pool.CreateGameObjectPool(bulletPrefab, minSize: 10);

// 获取对象
var bullet = pool.Spawn(position, rotation);

// 归还对象
pool.Despawn(bullet);

// 便捷方法
var obj = GridFramework.Pool.Spawn(prefab, position);
GridFramework.Pool.Despawn(obj);
```

---

## 🎯 总结

### 核心原则

1. **保持一致性**: 遵循框架的命名和结构规范
2. **简洁明了**: 代码应该易于理解和维护
3. **文档完善**: 公共 API 必须有清晰的注释
4. **可扩展性**: 使用接口和抽象类便于扩展
5. **性能优先**: 注意性能优化，避免常见陷阱

### 开发流程

1. 阅读本规范文档
2. 查看示例代码
3. 遵循命名和结构规范
4. 编写清晰的注释
5. 进行代码审查

### 持续改进

本文档会随着框架的发展不断更新，欢迎提出改进建议！

---

**文档版本**: v2.0.0  
**最后更新**: 2024-01  
**维护者**: GGFramework Team

